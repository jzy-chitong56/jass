//==================================================================================================
//  $Id: common.ai,v 1.66.2.1 2003/05/09 09:17:04 abond Exp $
//==================================================================================================

// 显示指定文本
native DebugS               takes string str                            returns nothing
    // 显示指定文本，带1个整数
    native DebugFI              takes string str, integer val               returns nothing
    // 显示指定文本，带1个单位类型（整数）
    native DebugUnitID          takes string str, integer val               returns nothing
    // 给指定玩家显示指定文本
    native DisplayText          takes integer p, string str                 returns nothing
    // 给指定玩家显示指定文本，带1个整数
    native DisplayTextI         takes integer p, string str, integer val    returns nothing
    // 给指定玩家显示指定文本，带2个整数
    native DisplayTextII        takes integer p, string str, integer v1, integer v2 returns nothing
    // 给指定玩家显示指定文本，带3个整数
    native DisplayTextIII       takes integer p, string str, integer v1, integer v2, integer v3 returns nothing
    // 查询AI脚本是否允许显示调试文本，以供开发者DEBUG
    native DoAiScriptDebug      takes nothing                               returns boolean
    // 获取当前脚本控制的AI玩家（非中立玩家）编号
    // 在1.29及以上版本中，返回的是0 ~ 23任意一个整数，以下则是0 ~ 11
    // 注：编号从0开始，即玩家1编号为0
    native GetAiPlayer          takes nothing                               returns integer
    // 获取升级英雄的单位类型
    // 英雄升级技能相关函数 
    native GetHeroId            takes nothing                               returns integer
    // 获取升级英雄的等级
    // 英雄升级技能相关函数 
    native GetHeroLevelAI       takes nothing                               returns integer
    
    // 获取指定的单位类型数量，含训练中及训练完成
    // 不含建筑，不统计该单位的等价单位
    native GetUnitCount         takes integer unitid                        returns integer
    // 获取指定玩家指定的单位类型数量，含训练中及训练完成
    // 不含建筑，不统计该单位的等价单位
    native GetPlayerUnitTypeCount takes player p, integer unitid            returns integer
    // 获取指定的单位类型数量，仅统计已训练完成
    // 不含建筑，不统计该单位的等价单位
    native GetUnitCountDone     takes integer unitid                        returns integer
    // 获取指定基地对应类型的单位数
    // 不统计该单位的等价单位
    // @param tn 基地编号，-1为不限
    // @param dn 是否包含训练/建造/升级中的单位/建筑
    native GetTownUnitCount     takes integer id, integer tn, boolean dn    returns integer
    // 获取指定单位/建筑类型的单位造价（金钱）
    native GetUnitGoldCost      takes integer unitid                        returns integer
    // 获取指定单位/建筑类型的单位造价（木材）
    native GetUnitWoodCost      takes integer unitid                        returns integer
    // 获取指定单位/建筑类型的训练/建造/升级时间（以秒为单位）
    native GetUnitBuildTime     takes integer unitid                        returns integer
    
    // 获取拥有的金矿数量
    // 亡灵/暗夜是检查所有玩家自己和附近中立被动玩家的金矿，而不是只查闹鬼金矿/被缠绕的金矿
    // 如果AI出生点有多座未被其他玩家占据的中立被动玩家金矿（如多矿开局或金矿距离过近的图），会导致亡灵/暗夜采矿异常
    // 因为HarvestGold（0，n）指向的是该函数在指定基地附近返回的第一座矿，当返回非闹鬼金矿/被缠绕的金矿，侍僧/小精灵就无法采矿
    // 该问题在1.36版本有所缓解，但并未完全修复，疑似低版本该函数获取附近金矿的距离至少有2200，高版本却只有1500
    native GetMinesOwned        takes nothing                               returns integer
    // 获取拥有的所有金矿未采集金钱数量之和
    // 亡灵/暗夜是检查所有玩家自己和附近中立被动玩家的金矿，而不是只查闹鬼金矿/被缠绕的金矿
    // 如果AI出生点有多个金矿，会导致统计值偏差
    native GetGoldOwned         takes nothing                               returns integer
    // 获取有金矿基地的编号，如果多座基地都有金矿，则返回最小编号
    // 可能只检查主城，如果亡灵开矿不造主城，会被视为无基地
    // 配合TownHasMine检查当前哪座基地有矿时，可以直接获取最小编号，并从该编号查起，避免分基地过多时的逐个查询
    native TownWithMine         takes nothing                               returns integer
    // 查询指定编号的基地是否有金矿
    // @param townid 基地编号，-1为不限
    native TownHasMine          takes integer townid                        returns boolean
    // 查询指定编号的基地是否拥有城镇（一、二或三本任意基地）
    // @param townid 基地编号，-1为不限
    native TownHasHall          takes integer townid                        returns boolean
    
    // 获取指定科技类型的当前等级（如攻防默认最大3级，大师级科技默认最大2级），未研究/未获得时为0
    native GetUpgradeLevel      takes integer id                            returns integer
    // 获取研究指定科技需要消耗的金钱数量（指定科技类型）
    native GetUpgradeGoldCost   takes integer id                            returns integer
    // 获取研究指定科技需要消耗的木材数量（指定科技类型）
    native GetUpgradeWoodCost   takes integer id                            returns integer
    // 获取下一个扩张点的编号（可能返回-1，视为获取失败）
    native GetNextExpansion     takes nothing                               returns integer
    // 获取大型攻击目标（可能返回null）
    // 因暴雪会往进攻大型目标的攻击组添加 默认攻击类型为攻城 的单位类型，故猜测该单位是建筑或位于建筑群中
    native GetMegaTarget        takes nothing                               returns unit
    // 获取指定玩家正在建造的建筑
    native GetBuilding          takes player p                              returns unit
    // 获取敌人强度，似乎是全部敌人强度之和
    native GetEnemyPower        takes nothing                               returns integer
    // 设置盟友当前的攻击目标（仅对AI盟友生效）
    // 运行后会将指定目标告知盟友，AI盟友可跨脚本获取该目标，如果有配合攻击代码，则可协同进攻（似乎同时会发送小地图信号告知真人玩家）
    native SetAllianceTarget    takes unit id                               returns nothing
    // 获取盟友当前的攻击目标
    // 用于夸脚本协同
    native GetAllianceTarget    takes nothing                               returns unit
    // 训练/建造/升级/研究指定单位/建筑/科技(指定数量,单位类型,基地)
    // @param town 基地编号，-1为不限
    native SetProduce           takes integer qty, integer id, integer town returns boolean
    // 取消指定单位/建筑的训练/建造/升级
    // 因单词为反召唤，怀疑可用于卖建筑（亡灵）
    native Unsummon             takes unit unitid                           returns nothing
    // 建造扩张点/分基地
    // @param peon 指定工人单位
    // @param id 建造的城镇单位类型
    native SetExpansion         takes unit peon, integer id                 returns boolean
    // 研究指定科技
    native SetUpgrade           takes integer id                            returns boolean
    // 设置英雄升级技能线程
    native SetHeroLevels        takes code func                             returns nothing
    // 是否设置新英雄
    // 意义不明，可能和英雄升级技能函数有关，暴雪战役AI默认设否，对战AI不设置
    native SetNewHeroes         takes boolean state                         returns nothing
    // 购买地精飞艇
    // 运行后AI会自动前往地精实验室并自动购买地精飞艇
    native PurchaseZeppelin     takes nothing                               returns nothing
    // 训练指定数量的合体单位类型
    // 运行后AI会分别训练a和b并合体，直到make数量达标，如角鹰兽和弓箭手合体
    // @param a 单位类型一
    // @param b 单位类型二
    // @param make 一和二合体而成的单位类型
    native MergeUnits           takes integer qty, integer a, integer b, integer make returns boolean
    // 训练指定数量的变形单位类型
    // 此变形不是英雄/熊德/鸟德/白牛/猎头/坦克的变身/升级，而是十胜石雕像和毁灭者这种额外付费的个体变形
    // 运行后AI会训练变形前单位并变形，直到数量达标
    native ConvertUnits         takes integer qty, integer id               returns boolean
    
    // 启用战役AI
    // 在游戏内启用未使用的玩家槽运行AI无效，仅对开局时玩家控制类型为电脑的玩家生效，这意味着玩家掉线后AI无法托管
    native SetCampaignAI        takes nothing                               returns nothing
    // 启用对战AI
    // 在游戏内启用未使用的玩家槽运行AI无效，仅对开局时玩家控制类型为电脑的玩家生效，这意味着玩家掉线后AI无法托管
    native SetMeleeAI           takes nothing                               returns nothing
    // 允许/禁止 优先攻击英雄
    native SetTargetHeroes      takes boolean state                         returns nothing
    // 允许/禁止 工人维修建筑
    native SetPeonsRepair       takes boolean state                         returns nothing
    // 启用/禁用 随机进攻路径
    native SetRandomPaths       takes boolean state                         returns nothing
    // 启用/禁用 保护真人盟友
    native SetDefendPlayer      takes boolean state                         returns nothing
    // 允许/禁止 英雄在受伤严重或遭受攻击时尝试逃跑
    native SetHeroesFlee        takes boolean state                         returns nothing
    // 允许/禁止 英雄购买物品
    // 允许时AI会购买补给品补血补蓝，还会购买法球，甚至是回城卷轴等有用的消耗品
    native SetHeroesBuyItems    takes boolean state                         returns nothing
    // 启用/禁用 没有怜悯（在敌人较弱或弱势时进攻）
    native SetWatchMegaTargets  takes boolean state                         returns nothing
    // 启用/禁用 受伤单位（血量50%以下）不编入攻击组
    native SetIgnoreInjured     takes boolean state                         returns nothing
    // 允许/禁止 英雄拾取物品
    native SetHeroesTakeItems   takes boolean state                         returns nothing
    // 允许/禁止 单位逃跑
    native SetUnitsFlee         takes boolean state                         returns nothing
    // 允许/禁止 攻击组逃跑
    native SetGroupsFlee        takes boolean state                         returns nothing
    // 启用/禁用 慢速采矿（每次采1金）
    native SetSlowChopping      takes boolean state                         returns nothing
    // 允许/禁止 基地变换
    // 允许时AI可以选择新基地，并将其作为采矿和撤退点
    native SetCaptainChanges    takes boolean allow                         returns nothing
    // 启用/禁用 聪明的炮火/主动攻城
    // 攻击类型为攻城的单位会优先攻击敌方建筑，同时AI也会尝试优先攻击敌方攻击类型为攻城的单位
    native SetSmartArtillery    takes boolean state                         returns nothing
    // 设置防守单位被杀后，AI的补充次数
    native SetReplacementCount  takes integer qty                           returns nothing
    // 允许/禁止 受伤单位回主基地或生命之泉疗伤
    native GroupTimedLife       takes boolean allow                         returns nothing
    // 从攻击组中移除受伤单位（血量50%以下）
    native RemoveInjuries       takes nothing                               returns nothing
    // 从攻击组中移除攻城单位（默认攻击类型为 攻城 的单位）
    native RemoveSiege          takes nothing                               returns nothing
    // 初始化攻击组
    // 建议在游戏开始调用以初始化，并且每次进攻循环前调用以重置
    native InitAssault          takes nothing                               returns nothing
    // 增加指定数量的指定单位类型到攻击组
    // 未被编入攻击组或防御组的单位类型不会跟随军队，只会留在出生点
    native AddAssault           takes integer qty, integer id               returns boolean
    // 增加指定数量的指定单位类型到防御组
    // 未被编入攻击组或防御组的单位类型不会跟随军队，只会留在出生点
    native AddDefenders         takes integer qty, integer id               returns boolean
    
    // 获取指定等级范围内的中立敌对玩家控制的单位
    // 在1.29及以上版本中，中立敌对玩家为玩家24，在以下版本则为12
    // @param min~max 等级下限及上限，合理利用数值区间可让AI在不同的发展阶段攻击不同等级的野怪营地
    // @param flyers_ok 为 ture 时获取飞行单位，为 false 时不获取，对空力量不足时不要获取飞行野怪
    native GetCreepCamp         takes integer min, integer max, boolean flyers_ok returns unit
    // 开始获取敌人主基地
    // 使用 WaitGetEnemyBase 停止获取，使用 GetEnemyBase 捕获获取到的单位
    native StartGetEnemyBase    takes nothing                               returns nothing
    // 查询是否已获取到敌人主基地
    // 使用 StartGetEnemyBase 开始获取，使用 GetEnemyBase 捕获获取到的单位
    native WaitGetEnemyBase     takes nothing                               returns boolean
    // 获取敌人主基地的单位
    // 必须先调用 StartGetEnemyBase 开始获取，再调用 WaitGetEnemyBase 判断是否完成获取，才能使用该函数获取本次得到的单位（可能返回null）
    native GetEnemyBase         takes nothing                               returns unit
    // 查询当前拟扩张点附近的敌方单位（普通玩家或中立敌对玩家的单位，可能返回null）
    native GetExpansionFoe      takes nothing                               returns unit
    // 获取敌人分基地（可能返回null）
    native GetEnemyExpansion    takes nothing                               returns unit
    // 获取扩张点的 X 坐标
    // 使用前必须已初始化 CreateCaptains
    native GetExpansionX        takes nothing                               returns integer
    // 获取扩张点的 Y 坐标
    // 使用前必须已初始化 CreateCaptains
    native GetExpansionY        takes nothing                               returns integer
    // 设置（军队）集合点
    native SetStagePoint        takes real x, real y                        returns nothing
    // 发布攻击组移动攻击命令（指定单位）
    // 当攻击组到达目标点，若未发现敌人或途中被击败且尚有单位幸存，攻击组将返回基地
    native AttackMoveKill       takes unit target                           returns nothing
    // 发布攻击组移动攻击命令（指定坐标）
    // 当攻击组到达目标点，若未发现敌人或途中被击败且尚有单位幸存，攻击组将返回基地
    native AttackMoveXY         takes integer x, integer y                  returns nothing
    // 在指定坐标卸载全部单位（空投）
    // 只对飞艇类单位的 卸载 技能生效，且AI无需任何辅助代码就能自己控制好飞艇的装卸（运输船不行）
    // 建议不要忽略飞艇类单位的警戒点，否则AI不会自动控制飞艇装卸
    native LoadZepWave          takes integer x, integer y                  returns nothing
    // 发布自杀式攻击命令（指定玩家），返回false代表未执行
    // 理论上是一路打到指定玩家的出生点
    // 暴雪用于战役AI
    // @param check_full 怀疑是 是否检查攻击组满血
    native SuicidePlayer        takes player id, boolean check_full         returns boolean
    // 发布自杀式攻击命令（指定玩家单位），返回false代表未执行
    // 和SuicidePlayer的区别怀疑是 只要攻击到该玩家任意单位即可，无需一路打到玩家出生点
    // 暴雪用于战役AI
    // @param check_full 怀疑是 是否检查攻击组满血
    native SuicidePlayerUnits   takes player id, boolean check_full         returns boolean
    // 查询攻击组战斗状态，带入真时查询是否在战斗，带入假时查询是否不在战斗
    native CaptainInCombat      takes boolean attack_captain                returns boolean
    // 查询指定单位是否有防御塔保护
    native IsTowered            takes unit target                           returns boolean
    // 清理上一次的AI采集工人分配设置
    // 暴雪在每次运行 HarvestGold 和 HarvestWood 前都进行了清理
    // 清理后AI可能会交换多个基地之间的农民，比如让A矿的农民去B矿工作，反之亦然
    native ClearHarvestAI       takes nothing                               returns nothing
    // 分配指定数量的工人在指定基地采集金矿
    // 如果金矿和基地之间最短距离的路线可以游过深水地形到达，两栖工人会优先走最短距离到达金矿，但其采集完成返回时自动会停在岸边驻足良久才继续返回或永久驻足，就像它忘记自己可以游泳一样
    // @param town 0为第一个有矿的基地，大于0则是对应每个分基地，小于0时可能被视为0
    // @param peons 分配的工人数量，每座矿每次应该是5（或金矿最大容量），可分两行实现（第一行分配3，第二行分配2，中间隔着采木分配），确保开局有工人采木，若某矿分配未满5，再使用代码或共享操作补满5工人采这座矿后，待以后分配满5时，被分配的工人会因无法进矿而挂机（暗夜/亡灵尤为严重），小于0时视为0
    native HarvestGold          takes integer town, integer peons           returns nothing
    // 分配指定数量的工人在指定基地采集木材
    // 如果树和基地之间最短距离的路线可以游过深水地形到达，两栖工人会优先走最短距离到达树，但其采集完成返回时自动停会在岸边，就像它忘记自己可以游泳一样
    // @param town 0为第一个有矿的基地，大于0则是对应每个分基地，小于0时可能被视为0
    // @param peons 分配的工人数量，小于0时视为0
    native HarvestWood          takes integer town, integer peons           returns nothing
    // 获取开分基地的工人，系统会随机返回一个工人单位给AI，可能返回null或已死亡单位，建议自写代码辅助获取替补单位
    // 如果AI有盟友，返回null的概率似乎会增加，如果是暗夜，建议另行判断工人是否在金矿内（是否运输单位），因为AI不会操作其离开金矿
    // 使用前必须已初始化 CreateCaptains
    native GetExpansionPeon     takes nothing                               returns unit
    // 停止聚集，必须调用（默认初始化时自动调用，无需理会），调用后，被训练的单位才会进行防守，否则只会在训练他们的建筑附近
    native StopGathering        takes nothing                               returns nothing
    // 在指定坐标增加指定类型的防守单位
    // 单位死亡后，AI会自动填补新防守单位，但每个点默认只增加3次，超过3次可使用 FillGuardPosts 补充 或 使用 SetReplacementCount 设置新上限
    native AddGuardPost         takes integer id, real x, real y            returns nothing
    // 填补防守岗位（即时），当一个单位被杀后，AI会立即训练一个同类型单位填补其空位
    native FillGuardPosts       takes nothing                               returns nothing
    // 返回防守岗位
    native ReturnGuardPosts     takes nothing                               returns nothing
    // 创建攻击组，游戏开始时必须调用，否则无法调用进攻甚至会引起游戏崩溃
    native CreateCaptains       takes nothing                               returns nothing
    // 设置指定组（攻击组、防守组、两组一起执行）回家后的集结坐标
    // AI默认把单位聚在主基地的采矿路线上，应该就是这个坐标
    // @param which 攻击组、防守组或两组，即 1，2或3
    native SetCaptainHome       takes integer which, real x, real y         returns nothing
    // 发布攻击组复位命令（回到 SetCaptainHome 的集结点）
    native ResetCaptainLocs     takes nothing                               returns nothing
    // 转移基地到指定坐标
    native ShiftTownSpot        takes real x, real y                        returns nothing
    // 运输/传送攻击组到指定坐标，似乎不能让AI使用回本卷轴或群体传送
    native TeleportCaptain      takes real x, real y                        returns nothing
    // 清除攻击组当前的攻击目标，清除后组会在一瞬间停止攻击，然后重新获取攻击目标
    native ClearCaptainTargets  takes nothing                               returns nothing
    // 发布攻击组攻击命令（指定坐标）
    // 可配合 DisablePathing 控制是否允许攻击组在路上战斗（移动攻击）
    native CaptainAttack        takes real x, real y                        returns nothing
    // 发布攻击组攻击命令（指定玩家单位）
    native CaptainVsUnits       takes player id                             returns nothing
    // 发布攻击组攻击命令（指定玩家）
    native CaptainVsPlayer      takes player id                             returns nothing
    // 发布攻击组回家命令
    native CaptainGoHome        takes nothing                               returns nothing
    // 查询攻击组是否在家
    native CaptainIsHome        takes nothing                               returns boolean
    // 查询攻击组是否满血
    native CaptainIsFull        takes nothing                               returns boolean
    // 查询攻击组是否为空（未创建或已阵亡或已创建但不可用-比如控制权转移或被删除）
    native CaptainIsEmpty       takes nothing                               returns boolean
    // 获取攻击组所在进攻/防御组规模（单位数量），数值越高，规模越大
    native CaptainGroupSize     takes nothing                               returns integer
    // 获取攻击组准备情况，似乎同时比对当前生命值和魔法值与其最大值
    // 似乎是百分制，数值越高，准备越充分
    native CaptainReadiness     takes nothing                               returns integer
    // 查询攻击组是否在撤退
    native CaptainRetreating    takes nothing                               returns boolean
    // 获取攻击组生命平均值
    // 取组内所有单位当前生命值百分比的平均值
    native CaptainReadinessHP   takes nothing                               returns integer
    // 获取攻击组魔法平均值
    // 取组内所有单位当前魔法值百分比的平均值
    native CaptainReadinessMa   takes nothing                               returns integer
    // 查询攻击组是否到达目的地
    native CaptainAtGoal        takes nothing                               returns boolean
    // 查询地图上是否还有中立敌对玩家的单位，即野怪
    // 在1.29及以上版本中，中立敌对玩家为玩家24，在以下版本则为12
    native CreepsOnMap          takes nothing                               returns boolean
    // 添加指定单位类型到自杀攻击组，指定单位类型和数量
    // 暴雪用于战役AI
    native SuicideUnit          takes integer count, integer unitid         returns nothing
    // 添加指定单位到自杀攻击组
    // 暴雪用于战役AI
    // @param ct 数量
    // @param uid 单位类型
    // @param pid 玩家编号
    native SuicideUnitEx        takes integer ct, integer uid, integer pid  returns nothing
    // 开始线程
    // AI脚本最多可运行6条独立线程，且同时运行（包含默认线程，自行添加前请检查已调用的默认线程数量）
    // 线程类似一条独立运行的功能，如果其内部没有无限循环或循环可以随意退出，则该线程运行完后会失效，因此一般官方的线程都是无限循环的
    // 变量支持跨线程使用，但在一条线程运行到读取变量时，该变量可能已在之前被另一个线程改写，于是造成滞后的假象
    native StartThread          takes code func                             returns nothing
    // 等待指定时间，按秒计时（等待期间不执行任何代码）
    native Sleep                takes real seconds                          returns nothing
    // 查询指定单位是否存活
    native UnitAlive            takes unit id                               returns boolean
    // 查询指定单位是否不可见（隐身）
    native UnitInvis            takes unit id                               returns boolean
    // 查询攻击组已忽略的指定类型单位的数量
    native IgnoredUnits         takes integer unitid                        returns integer
    // 查询AI的任意基地是否被攻击
    // 与小地图警报的触发条件相同，但只针对基地
    native TownThreatened       takes nothing                               returns boolean
    // 禁止在未到达目的地前（攻击组/防御组移动过程中）战斗
    native DisablePathing       takes nothing                               returns nothing
    // 获取队列中的命令数量
    native SetAmphibious        takes nothing                               returns nothing
    
    // 获取命令类型
    // 可通过BJ发送命令，未发送时获取的类型是0，获取后命令序列增加1，请用 PopLastCommand 减少序列，完成排泄
    // 暴雪用于打破循环，exitwhen CommandsWaiting() != 0，比如电影结束后，BJ发送1给AI，这就实现了游戏初始化时运行AI，但电影结束前AI不进攻，只发展
    native CommandsWaiting      takes nothing                               returns integer
    // 获取最新的命令类型
    // 可通过BJ发送，未发送时获取的数据是0，命令包含类型和数据，在AI脚本初始化期间发送无效，如有需要，请在初始化（运行AI脚本）前发送
    // 需灵活运用，比如设定1类型为进攻命令，数据0 ~ N代表不同的攻击点，2类型为防守命令，数据0 ~ N代表不同的防御点
    native GetLastCommand       takes nothing                               returns integer
    // 获取最新命令的数据，在AI脚本初始化期间发送无效，如有需要，请在初始化（运行AI脚本）前发送
    // 可通过BJ发送，未发送时获取的数据是0，命令包含类型和数据
    // 需灵活运用，比如设定1类型为进攻命令，数据0 ~ N代表不同的攻击点，2类型为防守命令，数据0 ~ N代表不同的防御点
    native GetLastData          takes nothing                               returns integer
    // 将最新命令踢出队列，在AI脚本初始化期间发送无效，如有需要，请在初始化（运行AI脚本）前发送
    // 当排泄用，用完命令就调用
    native PopLastCommand       takes nothing                               returns nothing
    // 获取对战难度
    native MeleeDifficulty      takes nothing                               returns integer
    
    //============================================================================
    //  Globals for all AI scripts
    //============================================================================
    globals
    
        //--------------------------------------------------------------------
        //  HUMANS
        //--------------------------------------------------------------------
    
        // human heroes
    
        // 大法师
        constant integer ARCHMAGE           = 'Hamg'
        // 圣骑士
        constant integer PALADIN            = 'Hpal'
        // 山丘之王
        constant integer MTN_KING           = 'Hmkg'
        // 血魔法师
        constant integer BLOOD_MAGE         = 'Hblm'
    
        // human hero abilities
    
        // 英雄技能 天神下凡（山丘之王）
        constant integer AVATAR             = 'AHav'
        // 英雄技能 猛击（山丘之王）
        constant integer BASH               = 'AHbh'
        // 英雄技能 风暴之锤（山丘之王）
        constant integer THUNDER_BOLT       = 'AHtb'
        // 英雄技能 雷霆一击（山丘之王）
        constant integer THUNDER_CLAP       = 'AHtc'
        // 英雄技能 虔诚光环（圣骑士）
        constant integer DEVOTION_AURA      = 'AHad'
        // 英雄技能 圣盾术（圣骑士）
        constant integer DIVINE_SHIELD      = 'AHds'
        // 英雄技能 圣光术（圣骑士）
        constant integer HOLY_BOLT          = 'AHhb'
        // 英雄技能 复活术（圣骑士）
        constant integer RESURRECTION       = 'AHre'
        // 英雄技能 暴风雪（大法师）
        constant integer BLIZZARD           = 'AHbz'
        // 英雄技能 辉煌光环（大法师）
        constant integer BRILLIANCE_AURA    = 'AHab'
        // 英雄技能 群体传送（大法师）
        constant integer MASS_TELEPORT      = 'AHmt'
        // 英雄技能 水元素（大法师）
        constant integer WATER_ELEMENTAL    = 'AHwe'
        // 英雄技能 放逐（血法）
        constant integer BANISH             = 'AHbn'
        // 英雄技能 烈焰风暴（血法）
        constant integer FLAME_STRIKE       = 'AHfs'
        // 英雄技能 火凤凰（血法）
        constant integer SUMMON_PHOENIX     = 'AHpx'
        // 英雄技能 法力虹吸（血法）
        constant integer SIPHON_MANA        = 'AHdr'
    
        // special human heroes
    
        // 吉安娜
        constant integer JAINA              = 'Hjai'
        // 穆拉丁·铜须
        constant integer MURADIN            = 'Hmbr'
        // 加里瑟斯
        constant integer GARITHOS           = 'Hlgr'
        // 卡尔萨斯
        constant integer KAEL               = 'Hkal'
    
        // human units
    
        // 矮人直升机
        constant integer COPTER             = 'hgyr'
        // 矮人直升机
        constant integer GYRO               =  COPTER
        // 水元素
        constant integer ELEMENTAL          = 'hwat'
        // 人族步兵
        constant integer FOOTMAN            = 'hfoo'
        // 人族步兵
        constant integer FOOTMEN            =  FOOTMAN
        // 狮鹫骑士
        constant integer GRYPHON            = 'hgry'
        // 人族骑士
        constant integer KNIGHT             = 'hkni'
        // 矮人迫机炮
        constant integer MORTAR             = 'hmtm'
        // 农民
        constant integer PEASANT            = 'hpea'
        // 牧师
        constant integer PRIEST             = 'hmpr'
        // 矮人火枪手
        constant integer RIFLEMAN           = 'hrif'
        // 矮人火枪手
        constant integer RIFLEMEN           =  RIFLEMAN
        // 女巫
        constant integer SORCERESS          = 'hsor'
        // 攻城坦克
        constant integer TANK               = 'hmtt'
        // 攻城坦克
        constant integer STEAM_TANK         =  TANK
        // 攻城坦克（弹幕升级）
        constant integer ROCKET_TANK        = 'hrtt'
        // 民兵
        constant integer MILITIA            = 'hmil'
        // 魔法破坏者（破法）
        constant integer SPELL_BREAKER      = 'hspt'
        // 龙鹰骑士
        constant integer HUMAN_DRAGON_HAWK  = 'hdhw'
    
        // special human units
    
        // 血精灵牧师
        constant integer BLOOD_PRIEST       = 'hbep'
        // 血精灵女巫
        constant integer BLOOD_SORCERESS    = 'hbes'
        // 血精灵工人
        constant integer BLOOD_PEASANT      = 'nhew'
    
        // human buildings
    
        // 狮鹫笼
        constant integer AVIARY             = 'hgra'
        // 兵营（人族）
        constant integer BARRACKS           = 'hbar'
        // 铁匠铺
        constant integer BLACKSMITH         = 'hbla'
        // 炮塔（人族）
        constant integer CANNON_TOWER       = 'hctw'
        // 城堡（人族三本基地）
        constant integer CASTLE             = 'hcas'
        // 圣塔（人族）（编辑器无此单位 'htws'）
        constant integer CHURCH             = 'htws'
        // 圣塔（人族）（编辑器无此单位 'htws'）
        constant integer MAGE_TOWER         =  CHURCH
        // 防御塔（人族）
        constant integer GUARD_TOWER        = 'hgtw'
        // 农场
        constant integer HOUSE              = 'hhou'
        // 国王祭坛
        constant integer HUMAN_ALTAR        = 'halt'
        // 主城（人族二本基地）
        constant integer KEEP               = 'hkee'
        // 伐木场
        constant integer LUMBER_MILL        = 'hlum'
        // 神秘圣地
        constant integer SANCTUM            = 'hars'
        // 神秘圣地
        constant integer ARCANE_SANCTUM     =  SANCTUM
        // 城镇大厅（人族一本基地）
        constant integer TOWN_HALL          = 'htow'
        // 哨塔
        constant integer WATCH_TOWER        = 'hwtw'
        // 车间
        constant integer WORKSHOP           = 'harm'
        // 神秘宝藏室
        constant integer ARCANE_VAULT       = 'hvlt'
        // 神秘之塔（人族）
        constant integer ARCANE_TOWER       = 'hatw'
    
        // human upgrades
    
        // 科技 钢铁铸剑
        constant integer UPG_MELEE          = 'Rhme'
        // 科技 黑火药
        constant integer UPG_RANGED         = 'Rhra'
        // 科技 炮兵（人族）（编辑器无此科技 'Rhaa'）
        constant integer UPG_ARTILLERY      = 'Rhaa'
        // 科技 钢铁装甲
        constant integer UPG_ARMOR          = 'Rhar'
        // 科技 黄金（人族）（编辑器无此科技 'Rhmi'）
        constant integer UPG_GOLD           = 'Rhmi'
        // 科技 改良石工技术/加强型石工技术
        constant integer UPG_MASONRY        = 'Rhac'
        // 科技 照明弹
        constant integer UPG_SIGHT          = 'Rhss'
        // 科技 防御
        constant integer UPG_DEFEND         = 'Rhde'
        // 科技 坐骑作战训练
        constant integer UPG_BREEDING       = 'Rhan'
        // 科技 牧师专家级训练
        constant integer UPG_PRAYING        = 'Rhpt'
        // 科技 女巫专家级训练
        constant integer UPG_SORCERY        = 'Rhst'
        // 科技 镶钉皮甲
        constant integer UPG_LEATHER        = 'Rhla'
        // 科技 长管火枪
        constant integer UPG_GUN_RANGE      = 'Rhri'
        // 科技 改良伐木技术/改进型伐木效率
        constant integer UPG_WOOD           = 'Rhlh'
        // 科技 魔法岗哨
        constant integer UPG_SENTINEL       = 'Rhse'
        // 科技 散射（人族）（编辑器无此科技 'Rhsr'）
        constant integer UPG_SCATTER        = 'Rhsr'
        // 科技 飞行器炸弹
        constant integer UPG_BOMBS          = 'Rhgb'
        // 科技 风暴战锤
        constant integer UPG_HAMMERS        = 'Rhhb'
        // 科技 控制魔法
        constant integer UPG_CONT_MAGIC     = 'Rhss'
        // 科技 破片榴弹/碎片攻击
        constant integer UPG_FRAGS          = 'Rhfs'
        // 科技 火箭弹幕
        constant integer UPG_TANK           = 'Rhrt'
        // 科技 对空炮机/高射炮火
        constant integer UPG_FLAK           = 'Rhfc'
        // 科技 迷雾之云
        constant integer UPG_CLOUD          = 'Rhcd'
    
        //--------------------------------------------------------------------
        //  ORCS
        //--------------------------------------------------------------------
    
        // orc heroes
    
        // 剑圣
        constant integer BLADE_MASTER       = 'Obla'
        // 先知
        constant integer FAR_SEER           = 'Ofar'
        // 牛头人酋长
        constant integer TAUREN_CHIEF       = 'Otch'
        // 暗影猎手
        constant integer SHADOW_HUNTER      = 'Oshd'
    
        // special orc heroes
    
        // 格罗玛什·地狱咆哮（普通形态）
        constant integer GROM               = 'Ogrh'
        // 萨尔（骑狼）
        constant integer THRALL             = 'Othr'
    
        // orc hero abilities
    
        // 英雄技能 致命一击（剑圣）
        constant integer CRITICAL_STRIKE    = 'AOcr'
        // 英雄技能 镜像（剑圣）
        constant integer MIRROR_IMAGE       = 'AOmi'
        // 英雄技能 剑刃风暴（剑圣）
        constant integer BLADE_STORM        = 'AOww'
        // 英雄技能 疾风步（剑圣）
        constant integer WIND_WALK          = 'AOwk'
        // 英雄技能 闪电链（先知）
        constant integer CHAIN_LIGHTNING    = 'AOcl'
        // 英雄技能 地震术（先知）
        constant integer EARTHQUAKE         = 'AOeq'
        // 英雄技能 视界术（先知）
        constant integer FAR_SIGHT          = 'AOfs'
        // 英雄技能 野性之魂（召狼）（先知）
        constant integer SPIRIT_WOLF        = 'AOsf'
        // 英雄技能 坚韧光环（牛头）
        constant integer ENDURANE_AURA      = 'AOae'
        // 英雄技能 重生（牛头）
        constant integer REINCARNATION      = 'AOre'
        // 英雄技能 震荡波（牛头）
        constant integer SHOCKWAVE          = 'AOsh'
        // 英雄技能 战争践踏（牛头）
        constant integer WAR_STOMP          = 'AOws'
        // 英雄技能 治疗波（暗影猎手）
        constant integer HEALING_WAVE       = 'AOhw'
        // 英雄技能 妖术（暗影猎手）
        constant integer HEX                = 'AOhx'
        // 英雄技能 毒蛇结界（蛇棒）（暗影猎手）
        constant integer SERPENT_WARD       = 'AOsw'
        // 英雄技能 巫毒狂舞（友军无敌）（暗影猎手）
        constant integer VOODOO             = 'AOvd'
    
        // orc units
    
        // 兽族步兵（编辑器无此单位 'oang'）
        constant integer GUARDIAN           = 'oang'
        // 投石车
        constant integer CATAPULT           = 'ocat'
        // 巫医
        constant integer WITCH_DOCTOR       = 'odoc'
        // 兽族步兵
        constant integer GRUNT              = 'ogru'
        // 猎头者
        constant integer HEAD_HUNTER        = 'ohun'
        // 狂战士（猎头升级）
        constant integer BERSERKER          = 'otbk'
        // 科多兽
        constant integer KODO_BEAST         = 'okod'
        // 苦工
        constant integer PEON               = 'opeo'
        // 狼骑兵
        constant integer RAIDER             = 'orai'
        // 萨满祭司
        constant integer SHAMAN             = 'oshm'
        // 牛头人
        constant integer TAUREN             = 'otau'
        // 驭风者
        constant integer WYVERN             = 'owyv'
        // 蝙蝠骑士
        constant integer BATRIDER           = 'otbr'
        // 灵魂行者
        constant integer SPIRIT_WALKER      = 'ospw'
        // 灵魂行者（虚无形态）
        constant integer SPIRIT_WALKER_M    = 'ospm'
    
        // orc buildings
    
        // 风暴祭坛
        constant integer ORC_ALTAR          = 'oalt'
        // 兵营（兽族）
        constant integer ORC_BARRACKS       = 'obar'
        // 兽栏
        constant integer BESTIARY           = 'obea'
        // 战争磨坊
        constant integer FORGE              = 'ofor'
        // 堡垒（兽人三本基地）
        constant integer FORTRESS           = 'ofrt'
        // 大厅（兽人一本基地）
        constant integer GREAT_HALL         = 'ogre'
        // 灵魂小屋
        constant integer LODGE              = 'osld'
        // 据点（兽人二本基地）
        constant integer STRONGHOLD         = 'ostr'
        // 兽人地洞
        constant integer BURROW             = 'otrb'
        // 牛头人图腾
        constant integer TOTEM              = 'otto'
        // 了望塔
        constant integer ORC_WATCH_TOWER    = 'owtw'
        // 巫毒小屋
        constant integer VOODOO_LOUNGE      = 'ovln'
    
        // orc upgrades
    
        // 科技 精钢近战武器
        constant integer UPG_ORC_MELEE      = 'Rome'
        // 科技 精钢远程武器
        constant integer UPG_ORC_RANGED     = 'Rora'
        // 科技 火炮（兽族）（编辑器无此科技 'Roaa'）
        constant integer UPG_ORC_ARTILLERY  = 'Roaa'
        // 科技 精钢护甲
        constant integer UPG_ORC_ARMOR      = 'Roar'
        // 科技 战鼓伤害强化
        constant integer UPG_ORC_WAR_DRUMS  = 'Rwdm'
        // 科技 掠夺
        constant integer UPG_ORC_PILLAGE    = 'Ropg'
        // 科技 野蛮之力/狂暴力量
        constant integer UPG_ORC_BERSERK    = 'Robs'
        // 科技 粉碎伤害强化
        constant integer UPG_ORC_PULVERIZE  = 'Rows'
        // 科技 诱捕（兽族）
        constant integer UPG_ORC_ENSNARE    = 'Roen'
        // 科技 毒矛（兽族）
        constant integer UPG_ORC_VENOM      = 'Rovs'
        // 科技 巫医专家级训练
        constant integer UPG_ORC_DOCS       = 'Rowd'
        // 科技 萨满祭司专家级训练
        constant integer UPG_ORC_SHAMAN     = 'Rost'
        // 科技 尖刺障碍
        constant integer UPG_ORC_SPIKES     = 'Rosp'
        // 科技 加强型防御
        constant integer UPG_ORC_BURROWS    = 'Rorb'
        // 科技 巨魔再生
        constant integer UPG_ORC_REGEN      = 'Rotr'
        // 科技 火油瓶（兽族）
        constant integer UPG_ORC_FIRE       = 'Rolf'
        // 科技 灵魂行者专家级训练
        constant integer UPG_ORC_SWALKER    = 'Rowt'
        // 科技 狂战士升级
        constant integer UPG_ORC_BERSERKER  = 'Robk'
        // 科技 燃油（兽族）
        constant integer UPG_ORC_NAPTHA     = 'Robf'
        // 科技 混乱（中立）
        constant integer UPG_ORC_CHAOS      = 'Roch'
    
        // Warcraft 2 orc units
    
        // 食人魔法师
        constant integer OGRE_MAGI          = 'nomg'
        // 红色巨龙
        constant integer ORC_DRAGON         = 'nrwm'
        // 地精自爆工兵
        constant integer SAPPER             = 'ngsp'
        // 地精飞艇
        constant integer ZEPPLIN            = 'nzep'
        // 地精飞艇
        constant integer ZEPPELIN           =  ZEPPLIN
        // 兽人术士
        constant integer W2_WARLOCK         = 'nw2w'
        // 猪圈
        constant integer PIG_FARM           = 'npgf'
    
        // special orc units
    
        // 邪兽人步兵
        constant integer CHAOS_GRUNT        = 'nchg'
        // 邪兽人术士
        constant integer CHAOS_WARLOCK      = 'nchw'
        // 邪兽人狼骑兵
        constant integer CHAOS_RAIDER       = 'nchr'
        // 邪兽人苦工
        constant integer CHAOS_PEON         = 'ncpn'
        // 邪兽人科多兽
        constant integer CHAOS_KODO         = 'nckb'
        // 格罗玛什·地狱咆哮（喝下恶魔之血/着魔的）
        constant integer CHAOS_GROM         = 'Opgh'
        // 黑石氏族剑圣
        constant integer CHAOS_BLADEMASTER  = 'Nbbc'
        // 邪兽人地洞
        constant integer CHAOS_BURROW       = 'ocbw'
    
        //--------------------------------------------------------------------
        //  UNDEAD
        //--------------------------------------------------------------------
    
        // undead heroes
    
        // 死亡骑士
        constant integer DEATH_KNIGHT       = 'Udea'
        // 恐惧魔王
        constant integer DREAD_LORD         = 'Udre'
        // 巫妖
        constant integer LICH               = 'Ulic'
        // 地穴领主
        constant integer CRYPT_LORD         = 'Ucrl'
    
        // special undead heroes
    
        // 玛尔加尼斯
        constant integer MALGANIS           = 'Umal'
        // 提克迪奥斯
        constant integer TICHONDRIUS        = 'Utic'
        // 阿兹加洛
        constant integer PIT_LORD           = 'Npld'
        // 迪瑟洛克
        constant integer DETHEROC           = 'Udth'
    
        // undead hero abilities
    
        // 英雄技能 沉睡（恐惧魔王）
        constant integer SLEEP              = 'AUsl'
        // 英雄技能 吸血光环（恐惧魔王）
        constant integer VAMP_AURA          = 'AUav'
        // 英雄技能 腐臭蜂群（恐惧魔王）
        constant integer CARRION_SWARM      = 'AUcs'
        // 英雄技能 地狱火（恐惧魔王）
        constant integer INFERNO            = 'AUin'
        // 英雄技能 黑暗仪式（巫妖）
        constant integer DARK_RITUAL        = 'AUdr'
        // 英雄技能 枯萎凋零（巫妖）
        constant integer DEATH_DECAY        = 'AUdd'
        // 英雄技能 冰霜新星（巫妖）
        constant integer FROST_ARMOR        = 'AUfu'
        // 英雄技能 霜甲术（自动施法）（巫妖）
        constant integer FROST_NOVA         = 'AUfn'
        // 英雄技能 亡者再临（死骑）
        constant integer ANIM_DEAD          = 'AUan'
        // 英雄技能 凋零/死亡缠绕（死骑）
        constant integer DEATH_COIL         = 'AUdc'
        // 英雄技能 天灾/死亡契约（死骑）
        constant integer DEATH_PACT         = 'AUdp'
        // 英雄技能 邪恶光环（死骑）
        constant integer UNHOLY_AURA        = 'AUau'
        // 英雄技能 腐尸甲虫（小强）
        constant integer CARRION_SCARAB     = 'AUcb'
        // 英雄技能 穿刺（小强）
        constant integer IMPALE             = 'AUim'
        // 英雄技能 虫群风暴（小强）
        constant integer LOCUST_SWARM       = 'AUls'
        // 英雄技能 尖刺甲壳（小强）
        constant integer THORNY_SHIELD      = 'AUts'
    
        // undead units
    
        // 憎恶
        constant integer ABOMINATION        = 'uabo'
        // 侍僧
        constant integer ACOLYTE            = 'uaco'
        // 女妖
        constant integer BANSHEE            = 'uban'
        // 地穴恶魔
        constant integer PIT_FIEND          = 'ucry'
        // 地穴恶魔
        constant integer CRYPT_FIEND        =  PIT_FIEND
        // 钻地的地穴恶魔
        constant integer BURROWED_FIEND     = 'ucrm'
        // 冰霜巨龙
        constant integer FROST_WYRM         = 'ufro'
        // 石像鬼
        constant integer GARGOYLE           = 'ugar'
        // 石像鬼石像形态
        constant integer GARGOYLE_MORPH     = 'ugrm'
        // 食尸鬼
        constant integer GHOUL              = 'ugho'
        // 清道夫（绞肉机）
        constant integer MEAT_WAGON         = 'umtw'
        // 通灵师（亡灵男巫）
        constant integer NECRO              = 'unec'
        // 骷髅战士
        constant integer SKEL_WARRIOR       = 'uske'
        // 骷髅法师
        constant integer SKEL_MAGE          = 'uskm'
        // 影魔（阴影）
        constant integer SHADE              = 'ushd'
        // 邪灵空艇
        constant integer UNDEAD_BARGE       = 'uarb'
        // 黑曜石雕像
        constant integer OBSIDIAN_STATUE    = 'uobs'
        // 黑曜石雕像
        constant integer OBS_STATUE         =  OBSIDIAN_STATUE
        // 毁灭者
        constant integer BLK_SPHINX         = 'ubsp'
        // 腐尸甲虫（1级）
        constant integer CARRIONSCARAB1     = 'ucs1'
        // 腐尸甲虫（2级）
        constant integer CARRIONSCARAB2    = 'ucs2'
        // 钻地的腐尸甲虫（2级）
        constant integer CARRIONSCARABBURROWED2   = 'ucsB'
        // 腐尸甲虫（3级）
        constant integer CARRIONSCARAB3    = 'ucs3'
        // 钻地的腐尸甲虫（3级）
        constant integer CARRIONSCARABBURROWED3   = 'ucsC'

        // undead buildings
    
        // 闹鬼金矿
        constant integer UNDEAD_MINE        = 'ugol'
        // 黑暗祭坛
        constant integer UNDEAD_ALTAR       = 'uaod'
        // 埋骨地
        constant integer BONEYARD           = 'ubon'
        // 某种尖塔（不死族）（编辑器无此单位 'ugsp'）
        constant integer GARG_SPIRE         = 'ugsp'
        // 浮空城（大墓地）
        constant integer NECROPOLIS_1       = 'unpl'    // normal
        // 亡者大厅
        constant integer NECROPOLIS_2       = 'unp1'    // upgraded once
        // 黑色城堡
        constant integer NECROPOLIS_3       = 'unp2'    // full upgrade
        // 献祭深渊
        constant integer SAC_PIT            = 'usap'
        // 地穴（不死族兵营）
        constant integer CRYPT              = 'usep'
        // 屠宰场
        constant integer SLAUGHTERHOUSE     = 'uslh'
        // 诅咒神殿
        constant integer DAMNED_TEMPLE      = 'utod'
        // 通灵塔
        constant integer ZIGGURAT_1         = 'uzig'    // normal
        // 幽魂之塔
        constant integer ZIGGURAT_2         = 'uzg1'    // upgraded
        // 蛛魔之塔（冰塔）
        constant integer ZIGGURAT_FROST     = 'uzg2'    // frost tower
        // 坟场
        constant integer GRAVEYARD          = 'ugrv'
        // 遗物陵墓
        constant integer TOMB_OF_RELICS     = 'utom'
    
        // undead upgrades
    
        // 科技 邪恶力量
        constant integer UPG_UNHOLY_STR     = 'Rume'
        // 科技 生物攻击
        constant integer UPG_CR_ATTACK      = 'Rura'
        // 科技 邪恶护甲
        constant integer UPG_UNHOLY_ARMOR   = 'Ruar'
        // 科技 食尸
        constant integer UPG_CANNIBALIZE    = 'Ruac'
        // 科技 食尸鬼狂暴
        constant integer UPG_GHOUL_FRENZY   = 'Rugf'
        // 科技 蛛网
        constant integer UPG_FIEND_WEB      = 'Ruwb'
        // 科技 疑似与憎恶相关（不死族）（编辑器无此科技'Ruab'）
        constant integer UPG_ABOM           = 'Ruab'
        // 科技 石像形态
        constant integer UPG_STONE_FORM     = 'Rusf'
        // 科技 通灵师/亡灵男巫专家级训练
        constant integer UPG_NECROS         = 'Rune'
        // 科技 女妖专家级训练
        constant integer UPG_BANSHEE        = 'Ruba'
        // 科技 背包（不死族）（原文'Rump'有误）
        constant integer UPG_MEAT_WAGON     = 'Rupm'
        // 科技 冰冻吐息
        constant integer UPG_WYRM_BREATH    = 'Rufb'
        // 科技 骷髅持久术/骨质增强术
        constant integer UPG_SKEL_LIFE      = 'Rusl'
        // 科技 骷髅精通/骷髅法术
        constant integer UPG_SKEL_MASTERY   = 'Rusm'
        // 科技 发掘尸体
        constant integer UPG_EXHUME         = 'Ruex'
        // 科技 牺牲（不死族）（编辑器无此科技'Rurs'）
        constant integer UPG_SACRIFICE      = 'Rurs'
        // 科技 疑似憎恶自爆（不死族）（编辑器无此科技'Ruax'）
        constant integer UPG_ABOM_EXPL      = 'Ruax'
        // 科技 生物甲壳
        constant integer UPG_CR_ARMOR       = 'Rucr'
        // 科技 疾病之云
        constant integer UPG_PLAGUE         = 'Rupc'
        // 科技 毁灭者形态
        constant integer UPG_BLK_SPHINX     = 'Rusp'
        // 科技 钻地
        constant integer UPG_BURROWING      = 'Rubu'
    
        //--------------------------------------------------------------------
        //  ELVES
        //--------------------------------------------------------------------
    
        // elf heroes
    
        // 恶魔猎手
        constant integer DEMON_HUNTER       = 'Edem'
        // 恶魔猎手（变身形态）
        constant integer DEMON_HUNTER_M     = 'Edmm'
        // 丛林守护者
        constant integer KEEPER             = 'Ekee'
        // 月之女祭司
        constant integer MOON_CHICK         = 'Emoo'
        // 月之女祭司
        constant integer MOON_BABE          =  MOON_CHICK
        // 月之女祭司
        constant integer MOON_HONEY         =  MOON_CHICK
        // 守望者
        constant integer WARDEN             = 'Ewar'
    
        // special elf heroes
        // 希尔瓦娜斯
        constant integer SYLVANUS           = 'Hvwd'
        // 塞纳留斯
        constant integer CENARIUS           = 'Ecen'
        // 伊利丹（邪恶）
        constant integer ILLIDAN            = 'Eevi'
        // 伊利丹（恶魔变形）
        constant integer ILLIDAN_DEMON      = 'Eevm'
        // 玛維
        constant integer MAIEV              = 'Ewrd'
    
        // elf hero abilities
    
        // 英雄技能 自然之力（丛林守护者）
        constant integer FORCE_NATURE       = 'AEfn'
        // 英雄技能 纠缠根须（丛林守护者）
        constant integer ENT_ROOTS          = 'AEer'
        // 英雄技能 荆棘光环（丛林守护者）
        constant integer THORNS_AURA        = 'AEah'
        // 英雄技能 宁静（丛林守护者）
        constant integer TRANQUILITY        = 'AEtq'
        // 英雄技能 闪避（恶魔猎手）
        constant integer EVASION            = 'AEev'
        // 英雄技能 献祭（恶魔猎手）
        constant integer IMMOLATION         = 'AEim'
        // 英雄技能 法力燃烧（恶魔猎手）
        constant integer MANA_BURN          = 'AEmb'
        // 英雄技能 恶魔变形（恶魔猎手）
        constant integer METAMORPHOSIS      = 'AEme'
        // 英雄技能 灼热之箭（白虎）
        constant integer SEARING_ARROWS     = 'AHfa'
        // 英雄技能 斥候（白虎）
        constant integer SCOUT              = 'AEst'
        // 英雄技能 星辰坠落（流星雨）（白虎）
        constant integer STARFALL           = 'AEsf'
        // 英雄技能 强击光环（白虎）
        constant integer TRUESHOT           = 'AEar'
        // 英雄技能 闪现（守望者）
        constant integer BLINK              = 'AEbl'
        // 英雄技能 刀扇（守望者）
        constant integer FAN_KNIVES         = 'AEfk'
        // 英雄技能 暗影突袭（守望者）
        constant integer SHADOW_TOUCH       = 'AEsh'
        // 英雄技能 复仇（守望者）
        constant integer VENGEANCE          = 'AEsv'
    
        // elf units
    
        // 小精灵
        constant integer WISP               = 'ewsp'
        // 弓箭手
        constant integer ARCHER             = 'earc'
        // 猛禽德鲁伊（鸟德）（人形）
        constant integer DRUID_TALON        = 'edot'
        // 猛禽德鲁伊（鸟德）（鸦形）
        constant integer DRUID_TALON_M      = 'edtm'
        // 投刃车
        constant integer BALLISTA           = 'ebal'
        // 利爪德鲁伊（熊德）（人形）
        constant integer DRUID_CLAW         = 'edoc'
        // 利爪德鲁伊（熊德）（熊形）
        constant integer DRUID_CLAW_M       = 'edcm'
        // 树妖（小鹿）
        constant integer DRYAD              = 'edry'
        // 角鹰兽
        constant integer HIPPO              = 'ehip'
        // 角鹰兽骑士
        constant integer HIPPO_RIDER        = 'ehpr'
        // 女猎手
        constant integer HUNTRESS           = 'esen'
        // 奇美拉
        constant integer CHIMAERA           = 'echm'
        // 树人
        constant integer ENT                = 'efon'
        // 山岭巨人
        constant integer MOUNTAIN_GIANT     = 'emtg'
        // 精灵龙
        constant integer FAERIE_DRAGON      = 'efdr'
    
        // special elf units
    
        // 弓箭手（高等精灵）
        constant integer HIGH_ARCHER        = 'nhea'
        // 队/船长
        constant integer HIGH_FOOTMAN       = 'hcth'
        // 队/船长
        constant integer HIGH_FOOTMEN       =  HIGH_FOOTMAN
        // 剑士（高等精灵）
        constant integer HIGH_SWORDMAN      = 'hhes'
        // 龙鹰（高等精灵）
        constant integer DRAGON_HAWK        = 'nws1'
        // 腐化的树人
        constant integer CORRUPT_TREANT     = 'nenc'
        // 剧毒树人
        constant integer POISON_TREANT      = 'nenp'
        // 瘟疫树人
        constant integer PLAGUE_TREANT      = 'nepl'
        // 珊蒂斯
        constant integer SHANDRIS           = 'eshd'
    
        // elf buildings
    
        // 知识古树
        constant integer ANCIENT_LORE       = 'eaoe'
        // 战争古树
        constant integer ANCIENT_WAR        = 'eaom'
        // 风之古树
        constant integer ANCIENT_WIND       = 'eaow'
        // 纪元之树（暗夜二本）
        constant integer TREE_AGES          = 'etoa'
        // 永恒之树（暗夜三本）
        constant integer TREE_ETERNITY      = 'etoe'
        // 生命之树（暗夜一本）
        constant integer TREE_LIFE          = 'etol'
        // 守护古树
        constant integer ANCIENT_PROTECT    = 'etrp'
        // 长者祭坛
        constant integer ELF_ALTAR          = 'eate'
        // 熊窝（暗夜精灵族）（编辑器无此单位）
        constant integer BEAR_DEN           = 'edol'
        // 奇美拉栖木
        constant integer CHIMAERA_ROOST     = 'edos'
        // 猎手大厅
        constant integer HUNTERS_HALL       = 'edob'
        // 月亮井
        constant integer MOON_WELL          = 'emow'
        // 被缠绕的金矿
        constant integer ELF_MINE           = 'egol'
        // 奇迹古树
        constant integer DEN_OF_WONDERS     = 'eden'
    
        // special elf buildings
    
        // 高等精灵农场
        constant integer ELF_FARM           = 'nefm'
        // 高等精灵警戒塔
        constant integer ELF_GUARD_TOWER    = 'negt'
        // 天怒塔
        constant integer HIGH_SKY           = 'negm'
        // 地怒塔 
        constant integer HIGH_EARTH         = 'negf'
        // 高等精灵警戒塔
        constant integer HIGH_TOWER         = 'negt'
        // 高等精灵兵营
        constant integer ELF_HIGH_BARRACKS  = 'nheb'
        // 腐化的生命之树
        constant integer CORRUPT_LIFE       = 'nctl'
        // 腐化的月亮井
        constant integer CORRUPT_WELL       = 'ncmw'
        // 腐化的守护古树
        constant integer CORRUPT_PROTECTOR  = 'ncap'
        // 腐化的战争古树
        constant integer CORRUPT_WAR        = 'ncaw'
    
        // elf upgrades
    
        // 科技 月之力量
        constant integer UPG_STR_MOON       = 'Resm'
        // 科技 野性力量
        constant integer UPG_STR_WILD       = 'Resw'
        // 科技 月之护甲
        constant integer UPG_MOON_ARMOR     = 'Rema'
        // 科技 强化外皮/加强隐藏
        constant integer UPG_HIDES          = 'Rerh'
        // 科技 夜视能力
        constant integer UPG_ULTRAVISION    = 'Reuv'
        // 科技 自然祝福
        constant integer UPG_BLESSING       = 'Renb'
        // 科技 哨兵
        constant integer UPG_SCOUT          = 'Resc'
        // 科技 升级月刃
        constant integer UPG_GLAIVE         = 'Remg'
        // 科技 强弓/硬弓
        constant integer UPG_BOWS           = 'Reib'
        // 科技 箭术/射击术
        constant integer UPG_MARKSMAN       = 'Remk'
        // 科技 猛禽德鲁伊专家级训练
        constant integer UPG_DRUID_TALON    = 'Redt'
        // 科技 利爪德鲁伊专家级训练
        constant integer UPG_DRUID_CLAW     = 'Redc'
        // 科技 驱除魔法（暗夜精灵族）
        constant integer UPG_ABOLISH        = 'Resi'
        // 科技 腐蚀吐息/腐蚀喷吐
        constant integer UPG_CHIM_ACID      = 'Recb'
        // 科技 角鹰兽训练/驯服角鹰兽
        constant integer UPG_HIPPO_TAME     = 'Reht'
        // 科技 锐锋之刃（投刃车）（原文'Repd'有误）
        constant integer UPG_BOLT           = 'Repb'
        // 科技 利爪之印/利爪之痕
        constant integer UPG_MARK_CLAW      = 'Reeb'
        // 科技 猛禽之印/猛禽之痕
        constant integer UPG_MARK_TALON     = 'Reec'
        // 科技 硬化体肤/硬化皮肤
        constant integer UPG_HARD_SKIN      = 'Rehs'
        // 科技 抗性体肤/抗性皮肤
        constant integer UPG_RESIST_SKIN    = 'Rers'
        // 科技 月井之春
        constant integer UPG_WELL_SPRING    = 'Rews'
    
        //--------------------------------------------------------------------
        // Neutral
        //--------------------------------------------------------------------
    
        // 恶魔之门
        constant integer DEMON_GATE         = 'ndmg'
        // 恶魔猎犬
        constant integer FELLHOUND          = 'nfel'
        // 地狱火
        constant integer INFERNAL           = 'ninf'
        // 末日守卫（标准）
        constant integer DOOMGUARD          = 'nbal'
        // 萨特
        constant integer SATYR              = 'nsty'
        // 萨特欺诈者
        constant integer TRICKSTER          = 'nsat'
        // 萨特影舞者
        constant integer SHADOWDANCER       = 'nsts'
        // 萨特窃魂者
        constant integer SOULSTEALER        = 'nstl'
        // 萨特唤魔者
        constant integer HELLCALLER         = 'nsth'
        // 骷髅弓箭手
        constant integer SKEL_ARCHER        = 'nska'
        // 骷髅神射手
        constant integer SKEL_MARKSMAN      = 'nskm'
        // 燃烧弓箭手
        constant integer SKEL_BURNING       = 'nskf'
        // 巨型骷髅战士
        constant integer SKEL_GIANT         = 'nskg'
        // 熊怪
        constant integer FURBOLG            = 'nfrl'
        // 熊怪追踪者
        constant integer FURBOLG_TRACKER    = 'nfrb'
        // 熊怪萨满
        constant integer FURBOLG_SHAMAN     = 'nfrs'
        // 熊怪勇士
        constant integer FURBOLG_CHAMP      = 'nfrg'
        // 熊怪萨满长者
        constant integer FURBOLG_ELDER      = 'nfre'
    
        //--------------------------------------------------------------------
        // NAGA
        //--------------------------------------------------------------------
    
        // naga heroes
    
        // 海巫（娜迦族）
        constant integer NAGA_SORCERESS     = 'Nngs' 
        // 瓦斯琪
        constant integer NAGA_VASHJ         = 'Hvsh' 
    
        // naga units
    
        // 毒鳍龙
        constant integer NAGA_DRAGON        = 'nsnp'        // old names
        // 纳迦海妖
        constant integer NAGA_WITCH         = 'nnsw'
        // 飞蛇
        constant integer NAGA_SERPENT       = 'nwgs' 
        // 龙龟（娜迦族）
        constant integer NAGA_HYDRA         = 'nhyc'    
        // 深海鱼人奴隶（娜迦族）
        constant integer NAGA_SLAVE         = 'nmpe'        // peon
        // 毒鳍龙
        constant integer NAGA_SNAP_DRAGON   =  NAGA_DRAGON  // weak ranged
        // 飞蛇
        constant integer NAGA_COUATL        =  NAGA_SERPENT // weak air
        // 纳迦海妖
        constant integer NAGA_SIREN         =  NAGA_WITCH   // caster
        // 纳迦侍从
        constant integer NAGA_MYRMIDON      = 'nmyr'        // knight
        // 深海鱼人掠夺者（娜迦族）
        constant integer NAGA_REAVER        = 'nnmg'        // footman
        // 龙龟（娜迦族）
        constant integer NAGA_TURTLE        =  NAGA_HYDRA   // siege
        // 纳迦皇家卫兵
        constant integer NAGA_ROYAL         = 'nnrg'        // royal guard
    
        // naga buildings
    
        // 潮汐神殿
        constant integer NAGA_TEMPLE        = 'nntt'        // town hall
        // 珊瑚礁
        constant integer NAGA_CORAL         = 'nnfm'        // farm
        // 艾萨拉圣所
        constant integer NAGA_SHRINE        = 'nnsa'        // sirens & couatls
        // 孵化场
        constant integer NAGA_SPAWNING      = 'nnsg'        // myrm, snap dragon, hydra
        // 潮汐守卫
        constant integer NAGA_GUARDIAN      = 'nntg'        // tower
        // 深渊祭坛
        constant integer NAGA_ALTAR         = 'nnad'        // altar
    
        // naga upgrades
    
        // 科技 珊瑚鳞甲
        constant integer UPG_NAGA_ARMOR     = 'Rnam'
        // 科技 珊瑚锋刃
        constant integer UPG_NAGA_ATTACK    = 'Rnat'
        // 科技 驱除魔法（娜迦族）
        constant integer UPG_NAGA_ABOLISH   = 'Rnsi'
        // 科技 纳迦海妖专家级训练
        constant integer UPG_SIREN          = 'Rnsw'
        // 科技 诱捕（娜迦族）
        constant integer UPG_NAGA_ENSNARE   = 'Rnen'
    
    
        //--------------------------------------------------------------------
    
        // 1分钟
        constant integer M1                 =    60
        // 2分钟
        constant integer M2                 =  2*60
        // 3分钟
        constant integer M3                 =  3*60
        // 4分钟
        constant integer M4                 =  4*60
        // 5分钟
        constant integer M5                 =  5*60
        // 6分钟
        constant integer M6                 =  6*60
        // 7分钟
        constant integer M7                 =  7*60
        // 8分钟
        constant integer M8                 =  8*60
        // 9分钟
        constant integer M9                 =  9*60
        // 10分钟
        constant integer M10                = 10*60
        // 11分钟
        constant integer M11                = 11*60
        // 12分钟
        constant integer M12                = 12*60
        // 13分钟
        constant integer M13                = 13*60
        // 14分钟
        constant integer M14                = 14*60
        // 15分钟
        constant integer M15                = 15*60
        // 难度 简单，可与对战难度划等号
        constant integer EASY               = 1
        // 难度 中等，可与对战难度划等号
        constant integer NORMAL             = 2
        // 难度 困难/疯狂，可与对战难度划等号
        constant integer HARD               = 3
        // 该难度未使用，困难/疯狂难度为HARD，可与对战难度划等号
        constant integer INSANE             = 4 // not used
        // 对战难度 简单，可与难度划等号
        constant integer MELEE_NEWBIE       = 1
        // 对战难度 中等，可与难度划等号
        constant integer MELEE_NORMAL       = 2
        // 对战难度 困难/疯狂，可与难度划等号
        constant integer MELEE_INSANE       = 3
        // 攻击组
        constant integer ATTACK_CAPTAIN     = 1
        // 防御组
        constant integer DEFENSE_CAPTAIN    = 2
        // 攻击组及防御组
        constant integer BOTH_CAPTAINS      = 3
        // 建造类型 单位或建筑
        // 用于训练单位/建造建筑
        constant integer BUILD_UNIT         = 1
        // 建造类型 科技
        // 用于研究科技
        constant integer BUILD_UPGRADE      = 2
        // 建造类型 分基地（分矿）
        // 用于建造分基地
        constant integer BUILD_EXPAND       = 3
        // 建议用于升级二本主基地科技，默认值50
        // 暴雪未使用该变量
        constant integer UPKEEP_TIER1       = 50
        // 建议用于升级三本主基地科技，默认值80
        // 暴雪未使用该变量
        constant integer UPKEEP_TIER2       = 80
    
        //--------------------------------------------------------------------
    
        // 当前AI玩家
        player  ai_player
        // 等待时间
        integer sleep_seconds
        // 黄金总计
        // 用于计算当前黄金数量在训练/建造/研究指定（数量的）单位/建筑/科技后，还剩多少钱
        integer total_gold              = 0
        // 木材总计
        // 用于计算当前木材数量在训练/建造/研究指定（数量的）单位/建筑/科技后，还剩多少木
        integer total_wood              = 0
        // 黄金预存数，使用后AI会一直保留该数量的黄金不使用
        // 该值默认为0，AI不会使用，需要自行赋值，在完成指定的训练/建造/研究后请即使清零，否则AI会一直保持这笔存款
        // 如果需要存木，请自行在 OneBuildLoop 添加
        integer gold_buffer             = 0 // usually for potion money
        // AI难度，该变量用于统一对地图难度、战难度和难度，便于书写和检索
        integer difficulty              = NORMAL
        // 攻击敌人基地延迟（按次计），攻城单位准备完毕后，简单难度需要循环3次后才攻击，中等难度需要循环3次后才攻击，困难/疯狂需要循环0次后才攻击，攻击后置零
        integer exp_seen                = 0
        // 默认人口建筑单位类型
        // 建议在自己的脚本中重新赋值
        integer racial_farm             = 'hhou'
        // 首发英雄单位类型
        // 使用非四族默认英雄时，建议在自己的脚本中重新赋值
        integer hero_id                 = 'Hamg'
        // 二发英雄单位类型
        // 使用非四族默认英雄时，建议在自己的脚本中重新赋值
        integer hero_id2                = 'Hmkg'
        // 三发英雄单位类型
        // 使用非四族默认英雄时，建议在自己的脚本中重新赋值
        integer hero_id3                = 'Hpal'
        // 技能数组
        integer array skill
        // 首发英雄技能数组
        integer array skills1
        // 二发英雄技能数组
        integer array skills2
        // 三发英雄技能数组
        integer array skills3
        // 最大英雄等级，默认为0，会在英雄升级后自动调整，上限由平衡常数决定
        integer max_hero_level          = 0
        // 攻击组数组 单位数量，每种单位使用1个引索
        integer array harass_qty
        // 攻击组数组 单位数量最大值，每种单位使用1个引索
        integer array harass_max
        // 攻击组数组 单位类型，每种单位使用1个引索
        integer array harass_units
        // 攻击组数列，当前已记录到攻击组的单位类型，在下次初始化前，AI会使用这些单位类型进行攻击
        integer harass_length           = 0
        // 防御组数组 单位数量，每种单位使用1个引索
        integer array defense_qty
        // 防御组数组 单位类型，每种单位使用1个引索
        integer array defense_units
        // 防御组数列，当前已记录到防御组的单位类型，在下次初始化前，AI会使用这些单位类型进行防御
        integer defense_length          = 0
        // 训练/建造/研究数组 建造数量序列，每发送一次训练/建造/研究命令时，引索加1
        integer array build_qty
        // 训练/建造/研究数组 建造类型（单位/建筑，科技，分基地）序列，每发送一次训练/建造/研究命令时，引索加1
        integer array build_type
        // 训练/建造/研究数组 单位/建筑/科技类型（具体的单位类型）序列，每发送一次训练/建造/研究命令时，引索加1
        integer array build_item
        // 训练/建造/研究数组 建造位置（在哪个主/分基地建造）序列，每发送一次训练/建造/研究命令时，引索加1
        integer array build_town
        // 训练/建造/研究数组数列，当前已记录到建造序列的单位/建筑/科技类型，在下次初始化前，AI会依次训练/建造/研究
        integer build_length            = 0
        // 战役采金工人数量，默认5
        integer campaign_gold_peons     = 5
        // 战役采木工人数量，默认3
        integer campaign_wood_peons     = 3
        // 战役等待时间，默认5秒
        integer campaign_basics_speed   = 5
        // 最小野怪（中立敌对玩家单位）等级，默认-1
        integer min_creeps              = -1
        // 最大野怪（中立敌对玩家单位）等级，默认-1
        integer max_creeps              = -1
        // 是否允许AI开设第一座基地，以采集黄金/木材
        boolean harvest_town1           = true
        // 是否允许AI开设第二座基地，以采集黄金/木材
        boolean harvest_town2           = true
        // 是否允许AI开设第三座基地，以采集黄金/木材
        boolean harvest_town3           = true
        // 战役人口建筑建造模式
        boolean do_campaign_farms       = true
        // 二发英雄是否存在
        boolean two_heroes              = false
        // 是否允许获取飞行野怪（中立敌对玩家单位），默认不允许
        boolean allow_air_creeps        = false
        // 是否攻击分矿的野怪（中立敌对玩家单位），默认允许
        boolean take_exp                = false
        // 多用于退出自杀等待
        boolean allow_signal_abort      = false
        // 是否已完成飞艇购买
        boolean ready_for_zeppelin      = true
        // 是否允许购买飞艇，默认为否
        boolean get_zeppelin            = false
        // 是否建造战役进攻单位
        boolean build_campaign_attackers = true
        // 用于开发调试
        boolean do_debug_cheats         = false
        // 是否在游戏中显示 Trace 文本（开启后可用于调试，只需要调用对应的 Trace 发送指定文本即可）
        boolean trace_on                = true
        // 是否允许飞艇空投
        boolean zep_next_wave           = false
        // 是否允许攻击组组建超时
        boolean form_group_timeouts     = true
    endglobals
    
    //============================================================================

    // 根据玩家槽查询玩家，槽从1开始计算，玩家从0开始计算，玩家数字恒比槽少1
    function PlayerEx takes integer slot returns player
        return Player(slot-1)
    endfunction
    
    //============================================================================

    // 显示文本，带1个指定文本
    function Trace takes string message returns nothing
        if trace_on then
            call DisplayText(GetAiPlayer(),message)
        endif
    endfunction
    
    //============================================================================

    // 显示文本，带1个指定文本，1个整数
    function TraceI takes string message, integer val returns nothing
        if trace_on then
            call DisplayTextI(GetAiPlayer(),message,val)
        endif
    endfunction
    
    //============================================================================

    // 显示文本，带1个指定文本，2个整数
    function TraceII takes string message, integer v1, integer v2 returns nothing
        if trace_on then
            call DisplayTextII(GetAiPlayer(),message,v1,v2)
        endif
    endfunction
    
    //============================================================================

    // 显示文本，带1个指定文本，3个整数
    function TraceIII takes string message, integer v1, integer v2, integer v3 returns nothing
        if trace_on then
            call DisplayTextIII(GetAiPlayer(),message,v1,v2,v3)
        endif
    endfunction
    
    //============================================================================

    // 初始化AI玩家和等待时间（sleep_seconds）
    function InitAI takes nothing returns nothing
        set ai_player = Player(GetAiPlayer())
        set sleep_seconds = 0
        call StopGathering()
    endfunction
    
    //============================================================================

    // 标准AI初始化程序，运行后AI将已对战模式开始工作，可指定3条线程并使其开始运行
    // @param heroes 默认用于英雄学习技能线程，可自定义
    // @param peons 默认用于工人采集分配线程，可自定义
    // @param attacks 默认用于攻击线程，可自定义
    function StandardAI takes code heroes, code peons, code attacks returns nothing
    
        local boolean isNewbie = (MeleeDifficulty() == MELEE_NEWBIE)
    
        call InitAI()
    
        call SetMeleeAI()
    
        call SetDefendPlayer(true)
        call SetGroupsFlee(not isNewbie)
        call SetHeroesBuyItems(not isNewbie)
        call SetHeroesFlee(true)
        call SetHeroesTakeItems(true)
        call SetIgnoreInjured(true)
        call SetPeonsRepair(true)
        call SetSmartArtillery(not isNewbie)
        call SetTargetHeroes(not isNewbie)
        call SetUnitsFlee(not isNewbie)
        call SetWatchMegaTargets(true)
    
        call CreateCaptains()
    
        call SetHeroLevels(heroes)
    
        call Sleep(0.1)
        call StartThread(peons)
        call StartThread(attacks)
    endfunction
    
    //============================================================================
    //  Utility Functions
    //============================================================================

    // 对比整数，取最小值
    function Min takes integer A, integer B returns integer
        if A < B then
            return A
        else
            return B
        endif
    endfunction

    // 对比整数，取最大值
    function Max takes integer A, integer B returns integer
        if A > B then
            return A
        else
            return B
        endif
    endfunction

    // 设置运输状态开启，用于飞艇空投，但鉴于AI本身会使用飞艇，无需使用该程序
    function SetZepNextWave takes nothing returns nothing
        set zep_next_wave = true
    endfunction

    // 自杀倒计时（等待），当指定的时间小于等于0及触发器有命令传入时会结束等待
    function SuicideSleep takes integer seconds returns nothing
        set sleep_seconds = sleep_seconds - seconds
        loop
            exitwhen seconds <= 0
            exitwhen allow_signal_abort and CommandsWaiting() != 0
    
            if seconds >= 5 then
                call Sleep(5)
                set seconds = seconds - 5
            else
                call Sleep(seconds)
                set seconds = 0
            endif
        endloop
    endfunction
    
    //============================================================================

    // 等待信号，等待从触发器发送的命令，若无发送，不会执行下一步
    function WaitForSignal takes nothing returns integer
        local integer cmd
        local boolean display = false //xxx
        loop
            exitwhen CommandsWaiting() != 0
    
            //xxx
            call Trace("waiting for a signal to begin AI script...\n")
            set display = true
            call Sleep(2)
            exitwhen CommandsWaiting() != 0
            call Sleep(2)
            exitwhen CommandsWaiting() != 0
            call Sleep(2)
            exitwhen CommandsWaiting() != 0
            call Sleep(2)
            exitwhen CommandsWaiting() != 0
            call Sleep(2)
            //xxx
    
        endloop
    
        //xxx
        if display then
            call Trace("signal received, beginning AI script\n")
        endif
        //xxx
    
        set cmd = GetLastCommand()
        call PopLastCommand()
        return cmd
    endfunction

    //============================================================================

    // 设置战役采木工人数量（指定数量）
    function SetWoodPeons takes integer count returns nothing
        set campaign_wood_peons = count
    endfunction
    
    //============================================================================

    // 设置战役采金工人数量（指定数量）
    function SetGoldPeons takes integer count returns nothing
        set campaign_gold_peons = count
    endfunction
    
    //============================================================================

    // 设置战役默认采木工人数量（传真时设置3个工人采木，传假时设置0个）
    function SetHarvestLumber takes boolean harvest returns nothing
        if harvest then
            set campaign_wood_peons = 3
        else
            set campaign_wood_peons = 0
        endif
    endfunction
    
    //============================================================================

    // 启用/禁用 攻击组组建超时
    function SetFormGroupTimeouts takes boolean state returns nothing
        set form_group_timeouts = state
    endfunction
    
    //============================================================================

    // 启用/禁用 战役人口建筑建造模式
    function DoCampaignFarms takes boolean state returns nothing
        set do_campaign_farms = state
    endfunction
    
    //============================================================================

    // 获取小型中立敌对玩家的单位（0~9级之间，不含飞行单位）
    function GetMinorCreep takes nothing returns unit
        return GetCreepCamp(0,9,false)
    endfunction
    
    //============================================================================

     // 获取大型中立敌对玩家的单位（10~100级之间，根据allow_air_creeps当前值确定是否获取飞行单位）
    function GetMajorCreep takes nothing returns unit
        return GetCreepCamp(10,100,allow_air_creeps)
    endfunction
    
    //============================================================================

    // 查询当前AI玩家的黄金数
    function GetGold takes nothing returns integer
        return GetPlayerState(ai_player,PLAYER_STATE_RESOURCE_GOLD)
    endfunction
    
    //============================================================================

    // 查询当前AI玩家的木材数
    function GetWood takes nothing returns integer
        return GetPlayerState(ai_player,PLAYER_STATE_RESOURCE_LUMBER)
    endfunction
    
    //============================================================================

    // 初始化建造序列数组长度
    function InitBuildArray takes nothing returns nothing
        set build_length = 0
    endfunction
    
    //============================================================================

    // 初始化攻击组数组长度
    function InitAssaultGroup takes nothing returns nothing
        set harass_length = 0
    endfunction
    
    //============================================================================

    // 初始化防御组数组长度
    function InitDefenseGroup takes nothing returns nothing
        set defense_length = 0
    endfunction
    
    //============================================================================

    // 初始化攻击组
    // 执行初始化攻击组数组长度、移除受伤单位、移除攻城单位
    function InitMeleeGroup takes nothing returns nothing
        call InitAssaultGroup()
        call RemoveInjuries()
        call RemoveSiege()
    endfunction
    
    //============================================================================

    // 准备自杀
    // 执行初始化攻击组数组长度、初始化防御组数组、战役采集（金和木）工人数量置零
    function PrepFullSuicide takes nothing returns nothing
        call InitAssaultGroup()
        call InitDefenseGroup()
        set campaign_gold_peons = 0
        set campaign_wood_peons = 0
    endfunction
    
    //============================================================================

    // 设置防守单位补充次数
    // @param easy 简单AI的补充次数
    // @param med 中等AI的补充次数
    // @param hard 疯狂AI的补充次数
    function SetReplacements takes integer easy, integer med, integer hard returns nothing
        if difficulty == EASY then
            call SetReplacementCount(easy)
        elseif difficulty == NORMAL then
            call SetReplacementCount(med)
        else
            call SetReplacementCount(hard)
        endif
    endfunction
    
    //============================================================================

    // 运行指定线程
    function StartTownBuilder takes code func returns nothing
        call StartThread(func)
    endfunction
    
    //============================================================================

    // 设置建造序列
    // 每次运行建造/训练都会被统一引导到此写入建造先后的排序，等 建造线程 建造/训练/研究，当 build_length 重置时，之前的建造/训练/研究队列清空
    // @param town 基地编号，-1为不限
    function SetBuildAll takes integer t, integer qty, integer unitid, integer town returns nothing
        if qty > 0 then
            set build_qty[build_length] = qty
            set build_type[build_length] = t
            set build_item[build_length] = unitid
            set build_town[build_length] = town
            set build_length = build_length + 1
        endif
    endfunction
    
    //============================================================================

    // 训练/建造/研究指定数量的指定类型单位/科技
    function SetBuildUnit takes integer qty, integer unitid returns nothing
        call SetBuildAll(BUILD_UNIT,qty,unitid,-1)
    endfunction
    
    //============================================================================

    // 继续训练/建造/研究指定类型的单位/科技
    // 如果当前训练/建造/研究指定/研究中的该类型单位/科技数量大于等于指定数量，则不建造
    function SetBuildNext takes integer qty, integer unitid returns nothing
        local integer has = GetUnitCount(unitid)
        if has >= qty then
            return
        endif
        call SetBuildAll(BUILD_UNIT,GetUnitCountDone(unitid)+1,unitid,-1)
    endfunction
    
    //============================================================================

    // 训练/建造/研究指定类型的单位/科技
    // @param easy 简单AI的数量
    // @param med 中等AI的数量
    // @param hard 疯狂AI的数量
    function SetBuildUnitEx takes integer easy, integer med, integer hard, integer unitid returns nothing
        if difficulty == EASY then
            call SetBuildAll(BUILD_UNIT,easy,unitid,-1)
        elseif difficulty == NORMAL then
            call SetBuildAll(BUILD_UNIT,med,unitid,-1)
        else
            call SetBuildAll(BUILD_UNIT,hard,unitid,-1)
        endif
    endfunction
    
    //============================================================================

    // 在指定编号的基地建造指定数量的单位/科技，一般用于在分矿造塔和其他建筑
    // @param town 基地编号，-1为不限
    function SecondaryTown takes integer town, integer qty, integer unitid returns nothing
        call SetBuildAll(BUILD_UNIT,qty,unitid,town)
    endfunction
    
    //============================================================================

    // 在指定编号的基地建造指定数量的单位/科技，一般用于在分矿造塔和其他建筑
    // @param town 基地编号，-1为不限
    function SecTown takes integer town, integer qty, integer unitid returns nothing
        call SetBuildAll(BUILD_UNIT,qty,unitid,town)
    endfunction
    
    //============================================================================

    // 研究指定科技
    // 简单难度AI默认不执行
    function SetBuildUpgr takes integer qty, integer unitid returns nothing
        if MeleeDifficulty() != MELEE_NEWBIE or qty == 1 then
            call SetBuildAll(BUILD_UPGRADE,qty,unitid,-1)
        endif
    endfunction
    
    //============================================================================

    // 研究指定科技
    // @param easy 简单AI的等级
    // @param med 中等AI的等级
    // @param hard 疯狂AI的等级
    function SetBuildUpgrEx takes integer easy, integer med, integer hard, integer unitid returns nothing
        if difficulty == EASY then
            call SetBuildAll(BUILD_UPGRADE,easy,unitid,-1)
        elseif difficulty == NORMAL then
            call SetBuildAll(BUILD_UPGRADE,med,unitid,-1)
        else
            call SetBuildAll(BUILD_UPGRADE,hard,unitid,-1)
        endif
    endfunction
    
    //============================================================================

    // 建造分基地
    function SetBuildExpa takes integer qty, integer unitid returns nothing
        call SetBuildAll(BUILD_EXPAND,qty,unitid,-1)
    endfunction
    
    //============================================================================

    // 开始研究科技
    // @param level 科技等级
    // @param upgid 科技类型
    function StartUpgrade takes integer level, integer upgid returns boolean
        local integer gold_cost
        local integer wood_cost
    
        if GetUpgradeLevel(upgid) >= level then
            return true
        endif
    
        set gold_cost = GetUpgradeGoldCost(upgid)
        if total_gold < gold_cost then
            return false
        endif
    
        set wood_cost = GetUpgradeWoodCost(upgid)
        if total_wood < wood_cost then
            return false
        endif
    
        return SetUpgrade(upgid)
    endfunction
    
    //============================================================================

    // 建造/训练指定单位类型
    // 当金大于1000，木大于500时造两个，否则造一个，默认用于建造工厂（造兵建筑）
    function BuildFactory takes integer unitid returns nothing
        if GetGold() > 1000 and GetWood() > 500 then
            call SetBuildUnit( 2, unitid )
        else
            call SetBuildUnit( 1, unitid )
        endif
    endfunction
    
    //============================================================================

    // 判断指定单位类型的数量（含建造/训练中）是否等于该单位类型总数量（不含建造/训练中），默认用于检测城镇类型的单位（基地）
    function HallsCompleted takes integer unitid returns boolean
        return GetUnitCount(unitid) == GetUnitCountDone(unitid) 
    endfunction
    
    //============================================================================

    // 在指定分基地建造指定单位类型，一般用于在分矿造塔或其他建筑
    // 训练单位无需使用此函数，AI会使用所有建筑训练，不论其在哪个基地，使用该函数建造/训练的单位会被登记为：制造于该分基地
    // @param townid 基地编号，-1为不限
    // @param qty 指定数量
    function GuardSecondary takes integer townid, integer qty, integer unitid returns nothing
        if TownHasHall(townid) and TownHasMine(townid) then
            call SecondaryTown( townid, qty, unitid )
        endif
    endfunction
    
    //============================================================================

    // 获取指定单位类型的数量
    // @param only_done 是否包含建造/训练中的单位
    // @param townid 基地编号，-1为不限
    function GetUnitCountEx takes integer unitid, boolean only_done, integer townid returns integer
        if townid == -1 then
            if only_done then
                return GetUnitCountDone(unitid)
            else
                return GetUnitCount(unitid)
            endif
        else
            return GetTownUnitCount(unitid,townid,only_done)
        endif
    endfunction
    
    //============================================================================

    // 获取指定单位类型的数量，默认用于等价物单位，如城镇/变形单位这一类升级/变形后还当同一种单位统计的单位类型
    // 例如，统计一本城镇时，会统计一、二、三城镇的数量，统计熊德时，会统计熊德（人形）和熊德（熊形）的数量
    // @param only_done 是否包含建造/训练中的单位
    // @param townid 基地编号，-1为不限
    function TownCountEx takes integer unitid, boolean only_done, integer townid returns integer
    
        local integer have_qty = GetUnitCountEx(unitid,only_done,townid)
    
        if unitid == TOWN_HALL then
            set have_qty = have_qty + GetUnitCountEx(KEEP,false,townid) + GetUnitCountEx(CASTLE,false,townid)
        elseif unitid == KEEP then
            set have_qty = have_qty  + GetUnitCountEx(CASTLE,false,townid)
    
        elseif unitid == WATCH_TOWER then
            set have_qty = have_qty + GetUnitCountEx(GUARD_TOWER,false,townid) + GetUnitCountEx(CANNON_TOWER,false,townid) + GetUnitCountEx(ARCANE_TOWER,false,townid)
    
        elseif unitid == PEASANT then
            set have_qty = have_qty + GetUnitCountEx(MILITIA,false,townid)
    
        elseif unitid == GREAT_HALL then
            set have_qty = have_qty + GetUnitCountEx(STRONGHOLD,false,townid) + GetUnitCountEx(FORTRESS,false,townid)
        elseif unitid == STRONGHOLD then
            set have_qty = have_qty + GetUnitCountEx(FORTRESS,false,townid)
    
        elseif unitid == HEAD_HUNTER then
            set have_qty = have_qty + GetUnitCountEx(BERSERKER,false,townid)
    
        elseif unitid == SPIRIT_WALKER then
            set have_qty = have_qty + GetUnitCountEx(SPIRIT_WALKER_M,false,townid)
        elseif unitid == SPIRIT_WALKER_M then
            set have_qty = have_qty + GetUnitCountEx(SPIRIT_WALKER,only_done,townid)
    
        elseif unitid == NECROPOLIS_1 then
            set have_qty = have_qty + GetUnitCountEx(NECROPOLIS_2,false,townid) + GetUnitCountEx(NECROPOLIS_3,false,townid)
        elseif unitid == NECROPOLIS_2 then
            set have_qty = have_qty + GetUnitCountEx(NECROPOLIS_3,false,townid)
    
        elseif unitid == ZIGGURAT_1 then
            set have_qty = have_qty + GetUnitCountEx(ZIGGURAT_2,false,townid) + GetUnitCountEx(ZIGGURAT_FROST,false,townid)
    
        elseif unitid == GARGOYLE then
            set have_qty = have_qty + GetUnitCountEx(GARGOYLE_MORPH,false,townid)
    
        elseif unitid == TREE_LIFE then
            set have_qty = have_qty + GetUnitCountEx(TREE_AGES,false,townid) + GetUnitCountEx(TREE_ETERNITY,false,townid)
        elseif unitid == TREE_AGES then
            set have_qty = have_qty + GetUnitCountEx(TREE_ETERNITY,false,townid)
    
        elseif unitid == DRUID_TALON then
            set have_qty = have_qty + GetUnitCountEx(DRUID_TALON_M,false,townid)
        elseif unitid == DRUID_TALON_M then
            set have_qty = have_qty + GetUnitCountEx(DRUID_TALON,only_done,townid)
    
        elseif unitid == DRUID_CLAW then
            set have_qty = have_qty + GetUnitCountEx(DRUID_CLAW_M,false,townid)
        elseif unitid == DRUID_CLAW_M then
            set have_qty = have_qty + GetUnitCountEx(DRUID_CLAW,only_done,townid)
    
        elseif unitid == ILLIDAN then
            set have_qty = have_qty + GetUnitCountEx(ILLIDAN_DEMON,false,townid)
    
        endif
        return have_qty
    endfunction
    
    //============================================================================

    // 统计指定单位类型的数量，包含建造/训练中，不限基地，默认用于统计城镇类型的单位（基地）
    function TownCountDone takes integer base returns integer
        return TownCountEx(base,true,-1)
    endfunction
    
    //============================================================================

    // 统计指定单位类型的数量，不包含建造/训练中，不限基地
    // 默认用于统计城镇类型的单位（基地）
    function TownCount takes integer base returns integer
        return TownCountEx(base,false,-1)
    endfunction
    
    //============================================================================

    // 建造分基地
    // @param build_it 为假时不执行任何操作，当 build_it 和 HallsCompleted(unitid) 都为真时才会建造
    function BasicExpansion takes boolean build_it, integer unitid returns nothing
        if build_it and HallsCompleted(unitid) then
            call SetBuildExpa( TownCount(unitid)+1, unitid )
        endif
    endfunction
    
    //============================================================================

    // 升级科技
    // @param baseid 指定科技类型
    // @param newid 升级等级
    function UpgradeAll takes integer baseid, integer newid returns nothing
        call SetBuildUnit( TownCountDone(baseid), newid )
    endfunction
    
    //============================================================================

    // 统计指定单位类型数量，不否包含建造/训练中
    // 默认用于统计城镇类型的单位（基地）
    // @param base 指定单位类型
    // @param townid 基地编号，-1为不限
    function TownCountTown takes integer base, integer townid returns integer
        return TownCountEx(base,false,townid)
    endfunction
    
    //============================================================================
    
    //  FoodPool
    //============================================================================

    // 根据人口占用情况训练指定单位类型
    // @param food 建议使用当前已使用的人口数
    // @param use1 单位类型1占用的人口数（单个）
    // @param use2 单位类型占用的人口数（单个）
    // @param strong 当 strong 为真时，不论 weak 如何，训练（（food - use1 * TownCount(id1)) / use2）个id2
    // @param weak 当 strong 为假且 weak 为真时，训练（(food - use2 * TownCount(id2)) / use1）个id1
    function FoodPool takes integer food, boolean weak, integer id1, integer use1, boolean strong, integer id2, integer use2 returns nothing
        if strong then
            call SetBuildUnit( (food - use1 * TownCount(id1)) / use2, id2 )
        elseif weak then
            call SetBuildUnit( (food - use2 * TownCount(id2)) / use1, id1 )
        endif
    endfunction
    
    //============================================================================
    
    //  MeleeTownHall
    //============================================================================

    // 补造分基地，当指定的基地有金矿且该基地没有城镇时，补造一个分基地
    // @param townid 基地编号，-1为不限
    function MeleeTownHall takes integer townid, integer unitid returns nothing
        if TownHasMine(townid) and not TownHasHall(townid) then
            call SecondaryTown ( townid, 1, unitid )
        endif
    endfunction
    
    //============================================================================

    // 等待指定的单位类型（不包含建造/训练中）数量达到指定数量，达到之前一直循环等待
    function WaitForUnits takes integer unitid, integer qty returns nothing
        loop
            exitwhen TownCountDone(unitid) == qty
            call Sleep(2)
        endloop
    endfunction
    
    //============================================================================

    // 训练单位/建造建筑
    // @param ask_qty 数量
    // @param town 基地编号，-1为不限
    // @param unitid 单位类型
    function StartUnit takes integer ask_qty, integer unitid, integer town returns boolean
        local integer have_qty
        local integer need_qty
        local integer afford_gold
        local integer afford_wood
        local integer afford_qty
        local integer gold_cost
        local integer wood_cost
    
        //------------------------------------------------------------------------
        // if we have all we're asking for then make nothing
        //
        if town == -1 then
            set have_qty = TownCount(unitid)
        else
            set have_qty = TownCountTown(unitid,town)
        endif
    
        if have_qty >= ask_qty then
            return true
        endif
        set need_qty = ask_qty - have_qty
    
        //------------------------------------------------------------------------
        // limit the qty we're requesting to the amount of resources available
        //
        set gold_cost = GetUnitGoldCost(unitid)
        set wood_cost = GetUnitWoodCost(unitid)
    
        if gold_cost == 0 then
            set afford_gold = need_qty
        else
            set afford_gold = total_gold / gold_cost
        endif
        if afford_gold < need_qty then
            set afford_qty = afford_gold
        else
            set afford_qty = need_qty
        endif
    
        if wood_cost == 0 then
            set afford_wood = need_qty
        else
            set afford_wood = total_wood / wood_cost
        endif
        if afford_wood < afford_qty then
            set afford_qty = afford_wood
        endif
    
        // if we're waiting on gold/wood; pause build orders
        if afford_qty < 1 then
            return false
        endif
    
        //------------------------------------------------------------------------
        // whether we make right now what we're requesting or not, assume we will
        // and deduct the cost of the units from our fake gold total right away
        //
        set total_gold = total_gold - gold_cost * need_qty
        set total_wood = total_wood - wood_cost * need_qty
    
        if total_gold < 0 then
            set total_gold = 0
        endif
        if total_wood < 0 then
            set total_wood = 0
        endif
    
        //------------------------------------------------------------------------
        // give the AI a chance to make the units (it may not be able to right now
        // but that doesn't stop us from trying other units after this as long
        // as we have enough money to make this AND the needed, unbuilt ones)
        //
        return SetProduce(afford_qty,unitid,town)
    endfunction
    
    //============================================================================

    // 等待指定的单位类型（包含建造/训练中）数量大于或等于指定数量，满足条件前循环等待，若120秒后仍未满足，自动退出
    // @param towns 指定数量
    // @param townid 基地单位类型
    function WaitForTown takes integer towns, integer townid returns nothing
        local integer i = 0
        loop
            call Sleep(10)
            exitwhen TownCount(townid) >= towns
            set i = i + 1
            exitwhen i == 12
        endloop
    endfunction
    
    //============================================================================

    // 开始建造分基地
    // @param qty 数量
    // @param hall 基地单位类型
    function StartExpansion takes integer qty, integer hall returns boolean
        local integer count
        local integer town
        local unit    peon
        local integer gold_cost
    
        set count = TownCount(hall)
        if count >= qty then
            return true
        endif
    
        set town = GetNextExpansion()
        if town == -1 then
            return true
        endif
    
        set take_exp = true
    
        set gold_cost = GetUnitGoldCost(hall)
        if gold_cost > total_gold then
            return false
        endif
        set total_gold = total_gold - gold_cost
    
        if GetExpansionFoe() != null then
            return true
        endif
    
        set peon = GetExpansionPeon()
        if peon != null then
            return SetExpansion(peon,hall)
        endif
    
        return true
    endfunction
    
    //============================================================================
    
    // 建造核心循环，负责执行队列中全部建造/训练/研究
    function OneBuildLoop takes nothing returns nothing
        local integer index = 0
        local integer qty
        local integer id
        local integer tp
    
        set total_gold = GetGold() - gold_buffer
        set total_wood = GetWood()
    
        loop
            exitwhen index == build_length
    
            set qty = build_qty [index]
            set id  = build_item[index]
            set tp  = build_type[index]
    
            //--------------------------------------------------------------------
            if tp == BUILD_UNIT then
                if not StartUnit(qty,id,build_town[index]) then
                    return
                endif
    
            //--------------------------------------------------------------------
            elseif tp == BUILD_UPGRADE then
                call StartUpgrade(qty,id)
    
            //--------------------------------------------------------------------
            else // tp == BUILD_EXPAND
                if not StartExpansion(qty,id) then
                    return
                endif
            endif
    
            set index = index + 1
        endloop
    endfunction
    
    //============================================================================
    
    // 错位等待，时间为 (base + spread * I2R(GetAiPlayer()) / I2R(GetPlayers())) 秒
    function StaggerSleep takes real base, real spread returns nothing
        call Sleep(base + spread * I2R(GetAiPlayer()) / I2R(GetPlayers()))
    endfunction
    
    //============================================================================
    
    // 建造线程，启用建造核心循环程序，并无限循环
    function BuildLoop takes nothing returns nothing
        call OneBuildLoop()
        call StaggerSleep(1,2)
        loop
            call OneBuildLoop()
            call Sleep(2)
        endloop
    endfunction
    
    //============================================================================
    
    // 开始运行建造线程（建造/训练/升级 分矿、单位和科技）
    function StartBuildLoop takes nothing returns nothing
        call StartThread(function BuildLoop)
    endfunction
    
    //============================================================================
    
    // 设置初始波次的等待时间
    function SetInitialWave takes integer seconds returns nothing
        set sleep_seconds = seconds
    endfunction
    
    //============================================================================
    
    // 在原基础上增加初始波次的等待时间
    function AddSleepSeconds takes integer seconds returns nothing
        set sleep_seconds = sleep_seconds + seconds
    endfunction
    
    //============================================================================
    
    // 永久等待（使用后不会退出，永久循环）
    function SleepForever takes nothing returns nothing
        call Trace("going to sleep forever\n") //xxx
        loop
            call Sleep(100)
        endloop
    endfunction
    
    //============================================================================
    
    // 开始游戏，运行后AI会开始建造/训练/升级 单位或科技
    function PlayGame takes nothing returns nothing
        call StartBuildLoop()
        call SleepForever()
    endfunction
    
    //============================================================================
    
    // 当指定类型的单位/科技少于1个时（包含建造/训练/研究中），建造/训练/研究1个，默认用于补充合体/变形类单位
    function ConvertNeeds takes integer unitid returns nothing
        if GetUnitCount(unitid) < 1 then
            call StartUnit(1,unitid,-1)
        endif
    endfunction
    
    //============================================================================
    
    // 建造/训练特殊单位（如角鹰骑士或毁灭者这类合体/变形单位），当指定单位类型的数量（含建造/训练中）大于等于指定数量时，该程序不会运行
    // @param desire 指定数量
    // @param unitid 指定单位类型
    function Conversions takes integer desire, integer unitid returns nothing
    
        if GetUnitCount(unitid) >= desire then
            return
        endif
    
        if unitid == HIPPO_RIDER then
            call ConvertNeeds(ARCHER)
            call ConvertNeeds(HIPPO)
            call MergeUnits(desire,ARCHER,HIPPO,HIPPO_RIDER)
    
        elseif unitid == BLK_SPHINX then
            call ConvertNeeds(OBS_STATUE)
            call ConvertUnits(desire,OBS_STATUE)
        endif
    endfunction
    
    //============================================================================
    
    // 设置攻击组
    // @param qty 最小数量
    // @param max 最大数量
    // @param unitid 单位类型
    function SetAssaultGroup takes integer qty, integer max, integer unitid returns nothing
        call Conversions(max,unitid)
    
        if qty <= 0 and TownCountDone(unitid) == 0 then
            return
        endif
        set harass_qty[harass_length] = qty
        set harass_max[harass_length] = max
        set harass_units[harass_length] = unitid
        set harass_length = harass_length + 1
    endfunction
    
    //============================================================================
    
    // 交错设置攻击组
    // @param e1~e3 简单AI添加的数量，可设置3个档位
    // @param m1~m3 中等AI添加的数量，可设置3个档位
    // @param h1~h3 疯狂AI添加的数量，可设置3个档位
    // @param u1~u3 添加的单位类型，可设置3种类型，与难度无关
    function Interleave3 takes integer e1, integer m1, integer h1, integer u1, integer e2, integer m2, integer h2, integer u2, integer e3, integer m3, integer h3, integer u3 returns nothing
        local integer i1 = 1
        local integer i2 = 1
        local integer i3 = 1
        local integer q1
        local integer q2
        local integer q3
    
        if difficulty == EASY then
            set q1 = e1
            set q2 = e2
            set q3 = e3
        elseif difficulty == NORMAL then
            set q1 = m1
            set q2 = m2
            set q3 = m3
        else // difficulty == HARD
            set q1 = h1
            set q2 = h2
            set q3 = h3
        endif
    
        loop
            exitwhen q1<=0 and q2<=0 and q3<=0
    
            if q1 > 0 then
                call SetAssaultGroup(i1,i1,u1)
                set q1 = q1 - 1
                set i1 = i1 + 1
            endif
    
            if q2 > 0 then
                call SetAssaultGroup(i2,i2,u2)
                set q2 = q2 - 1
                set i2 = i2 + 1
            endif
    
            if q3 > 0 then
                call SetAssaultGroup(i3,i3,u3)
                set q3 = q3 - 1
                set i3 = i3 + 1
            endif
        endloop
    endfunction
    
    //============================================================================
    
    // 将指定类型的单位添加到对战攻击组
    function SetMeleeGroup takes integer unitid returns nothing
        if unitid == hero_id then
            call SetAssaultGroup(1,9,unitid)
        else
            call SetAssaultGroup((TownCountDone(unitid)*3)/4,20,unitid)
        endif
    endfunction
    
    //============================================================================
    
    // 将指定类型的单位添加到防御组，默认用于战役
    function CampaignDefender takes integer level, integer qty, integer unitid returns nothing
        if qty > 0 and difficulty >= level then
            set defense_qty[defense_length] = qty
            set defense_units[defense_length] = unitid
            set defense_length = defense_length + 1
            call Conversions(qty,unitid)
            call SetBuildUnit(qty,unitid)
        endif
    endfunction
    
    //============================================================================
    
    // 将指定类型的单位添加到防御组，默认用于战役
    // @param easy 简单AI添加的数量
    // @param med 中等AI添加的数量
    // @param hard 疯狂AI添加的数量
    function CampaignDefenderEx takes integer easy, integer med, integer hard, integer unitid returns nothing
        if difficulty == EASY then
            call CampaignDefender(EASY,easy,unitid)
        elseif difficulty == NORMAL then
            call CampaignDefender(NORMAL,med,unitid)
        else
            call CampaignDefender(HARD,hard,unitid)
        endif
    endfunction
    
    //============================================================================
    
    // 将指定类型的单位添加到战役攻击组，默认用于战役
    // @param level AI难度，会与当前AI的难度进行比对，输入值必须大于等于当前AI难度时才会添加
    function CampaignAttacker takes integer level, integer qty, integer unitid returns nothing
        if qty > 0 and difficulty >= level then 
            call SetAssaultGroup(qty,qty,unitid)
        endif
    endfunction
    
    //============================================================================
    
    // 将指定类型的单位添加到攻击组，默认用于战役
    // @param easy 简单AI添加的数量
    // @param med 中等AI添加的数量
    // @param hard 疯狂AI添加的数量
    function CampaignAttackerEx takes integer easy, integer med, integer hard, integer unitid returns nothing
        if difficulty == EASY then
            call CampaignAttacker(EASY,easy,unitid)
        elseif difficulty == NORMAL then
            call CampaignAttacker(NORMAL,med,unitid)
        else
            call CampaignAttacker(HARD,hard,unitid)
        endif
    endfunction
    
    //============================================================================
    
    // 等待攻击组完成组建，即给AI一定的时间补充兵力
    // @param testReady 攻击组准备情况，为真时需要攻击组准备满50，为假时准备0即可
    // @param seconds 最长等待时间
    function FormGroup takes integer seconds, boolean testReady returns nothing
        local integer index
        local integer count
        local integer unitid
        local integer desire
        local integer readyPercent
    
        // normally test for CaptainReadiness() of 50%
        if testReady == true then
            set readyPercent = 50
            call Trace("forming group, requiring healthy guys\n") //xxx
        else
            set readyPercent = 0
            call Trace("forming group, unit health not important\n") //xxx
        endif
    
        call Trace("trying to gather forces\n") //xxx
    
        loop
            call SuicideSleep(seconds)
            call InitAssault()
    
            set index = 0
            loop
                exitwhen index == harass_length
    
                set unitid = harass_units[index]
                set desire = harass_max[index]
                set count  = TownCountDone(unitid)
    
                call Conversions(desire,unitid)
    
                if count >= desire then
                    call AddAssault(desire,unitid)
                else
                    set desire = harass_qty[index]
    
                    if count < desire then
                        call AddAssault(desire,unitid)
                    else
                        call AddAssault(count,unitid)
                    endif
                endif
    
                set index = index + 1
            endloop
    
            //xxx
            if form_group_timeouts and (sleep_seconds < -60) then
                call Trace("exit form group -- timeout\n")
            elseif CaptainInCombat(true) then
                call Trace("exit form group -- can't form while already in combat\n")
            elseif CaptainIsFull() and CaptainReadiness() >= readyPercent then
                call Trace("exit form group -- ready\n")
            endif
            //xxx
    
            // time out and send group anyway if time has already expired
            exitwhen form_group_timeouts and (sleep_seconds < -60)
            exitwhen CaptainInCombat(true)
            exitwhen CaptainIsFull() and CaptainReadiness() >= readyPercent
        endloop
    endfunction
    
    //============================================================================
    
    // 获取指定单位/科技类型的建造/训练/研究时间，用于备战（补充兵力）
    function WavePrepare takes integer unitid returns integer
        return GetUnitBuildTime(unitid)
    endfunction
    
    //============================================================================
    
    // 获取当前累计的等待时间（WavePrepare的累计时间）
    // 无等待时返回默认值 30秒
    function PrepTime takes nothing returns integer
        local integer unitid
        local integer missing
        local integer prep
        local integer count
        local integer largest = 30
        local integer index = 0
    
        loop
            exitwhen index == harass_length
    
            set unitid  = harass_units[index]
            set missing = harass_qty[index] + IgnoredUnits(unitid) - TownCount(unitid)
            set prep    = WavePrepare(unitid) * missing
    
            if prep > largest then
                set largest = prep
            endif
    
            set index = index + 1
        endloop
        call TraceI("next wave will require around %d seconds to build and gather\n",largest) //xxx
    
        return largest
    endfunction
    
    //============================================================================
    
    // 等待指定时间（seconds），并在等待结束后判断攻击组准备是否完成
    function PrepSuicideOnPlayer takes integer seconds returns boolean
        local integer wave_prep   = PrepTime()
        local integer save_length
    
        set save_length = harass_length
        set harass_length = 0
    
        call AddSleepSeconds(seconds)
        if sleep_seconds-wave_prep > 0 then
            call TraceI("going to sleep for %d seconds before gathering next attack wave\n",sleep_seconds-wave_prep) //xxx
            call SuicideSleep(sleep_seconds-wave_prep)
        endif
    
        call Trace("preparing suicide attack wave\n") //xxx
    
        set harass_length = save_length
        if harass_length < 1 then
            call Trace("ERROR - no units specificed, exiting early\n") //xxx
            return false
        endif
    
        return true
    endfunction
    
    //============================================================================
    
    // 进军等待
    // 攻击组撤退、攻击组到达目的地、攻击组回到家、攻击组为空 任意事件返回 是 时，结束等待
    function SleepUntilAtGoal takes nothing returns nothing
        loop
            exitwhen CaptainRetreating()
            exitwhen CaptainAtGoal()        // reached goal
            exitwhen CaptainIsHome()        // failed to path and returned home
            exitwhen CaptainIsEmpty()       // all units died
            call SuicideSleep(3)
        endloop
    endfunction
    
    //============================================================================
    
    // 战斗等待
    // 攻击组脱离战斗 或 攻击组为空 时，退出内层循环，当内层循环退出8次时，退出外层循环，两层循环都退出时，结束等待
    function SleepInCombat takes nothing returns nothing
        local integer count = 0
        debug call Trace("SleepInCombat\n")
        loop
            loop
                exitwhen not CaptainInCombat(true)  // goal is cleared
                exitwhen CaptainIsEmpty()           // duh
                call SuicideSleep(1)
            endloop
    
            set count = count + 1
            exitwhen count >= 8
        endloop
        debug call Trace("exit SleepInCombat\n")
    endfunction
    
    //============================================================================
    
    // 攻击组移动攻击（指定坐标）
    function AttackMoveXYA takes integer x, integer y returns nothing
    
        if zep_next_wave then
            call LoadZepWave(x,y)
            set zep_next_wave = false
        endif
    
        call AttackMoveXY(x,y)
        call SleepUntilAtGoal()
        call SleepInCombat()
    endfunction
    
    //============================================================================
    
    // 通报自杀攻击各波次进攻情况（默认使用Trace函数发送文字，查看可能需要打开调试模式）
    function SuicideOnPlayerWave takes nothing returns nothing
        call Trace("waiting for attack wave to enter combat\n") //xxx
        loop
            //xxx
            if allow_signal_abort and CommandsWaiting() != 0 then
                call Trace("ABORT -- attack wave override\n")
            endif
    
            if CaptainInCombat(true) then
                call Trace("done - captain has entered combat\n")
            endif
    
            if CaptainIsEmpty() then
                call Trace("done - all units are dead\n")
            endif
    
            if sleep_seconds < -300 then
                call Trace("done - timeout, took too long to reach engage the enemy\n")
            endif
            //xxx
    
            exitwhen allow_signal_abort and CommandsWaiting() != 0
    
            exitwhen CaptainInCombat(true)
            exitwhen CaptainIsEmpty()
            call SuicideSleep(10)
            exitwhen sleep_seconds < -300
        endloop
    
        call Trace("waiting for attack wave to die\n") //xxx
        loop
            //xxx
            if allow_signal_abort and CommandsWaiting() != 0 then
                call Trace("ABORT - attack wave override\n")
            endif
    
            if CaptainIsEmpty() then
                call Trace("done - all units are dead\n")
            endif
    
            if sleep_seconds < -300 then
                call Trace("done - timeout, took too long to reach engage the enemy\n")
            endif
            //xxx
    
            exitwhen allow_signal_abort and CommandsWaiting() != 0
    
            exitwhen CaptainIsEmpty()
            call SuicideSleep(10)
            exitwhen sleep_seconds < -300
        endloop
    endfunction
    
    //--------------------------------------------------------------------------------------------------

    // 设置自杀攻击各波次进攻（指定玩家和坐标）
    // @param standard 为真时会额外判断退出条件且不进攻指定坐标，为假时会进攻指定坐标
    // @param bldgs 当standard为真时，若bldgs为真，会额外判断退出条件 SuicidePlayer(p,sleep_seconds >= -60)，反之额外判断退出条件 SuicidePlayerUnits(p,sleep_seconds >= -60)
    // @param seconds 等待攻击组组建时间，若在指定时间后攻击组仍未完成组建，则不会进攻
    function CommonSuicideOnPlayer takes boolean standard, boolean bldgs, integer seconds, player p, integer x, integer y returns nothing
        local integer save_peons
    
        if not PrepSuicideOnPlayer(seconds) then
            return
        endif
    
        set save_peons = campaign_wood_peons
        set campaign_wood_peons = 0
    
        loop
            //xxx
            if allow_signal_abort and CommandsWaiting() != 0 then
                call Trace("ABORT -- attack wave override\n")
            endif
            //xxx
    
            exitwhen allow_signal_abort and CommandsWaiting() != 0
    
            loop
                exitwhen allow_signal_abort and CommandsWaiting() != 0
    
                call FormGroup(5,true)
                exitwhen sleep_seconds <= 0
                call TraceI("waiting %d seconds before suicide\n",sleep_seconds) //xxx
            endloop
    
            if standard then
                if bldgs then
                    exitwhen SuicidePlayer(p,sleep_seconds >= -60)
                else
                    exitwhen SuicidePlayerUnits(p,sleep_seconds >= -60)
                endif
            else
                call AttackMoveXYA(x,y)
            endif
    
            call TraceI("waiting %d seconds before timeout\n",60+sleep_seconds) //xxx
            call SuicideSleep(5)
        endloop
    
        set campaign_wood_peons = save_peons
        set harass_length = 0
    
        call SuicideOnPlayerWave()
    endfunction
    
    //--------------------------------------------------------------------------------------------------
   
    // 自杀式攻击（指定玩家）
    function SuicideOnPlayer takes integer seconds, player p returns nothing
        call CommonSuicideOnPlayer(true,true,seconds,p,0,0)
    endfunction
    
    //--------------------------------------------------------------------------------------------------
   
    // 自杀式攻击（指定玩家单位）
    function SuicideOnUnits takes integer seconds, player p returns nothing
        call CommonSuicideOnPlayer(true,false,seconds,p,0,0)
    endfunction
    
    //--------------------------------------------------------------------------------------------------
   
    // 自杀式攻击（指定玩家坐标）
    function SuicideOnPoint takes integer seconds, player p, integer x, integer y returns nothing
        call CommonSuicideOnPlayer(false,false,seconds,p,x,y)
    endfunction
    
    //============================================================================
    
    // 等待自杀命令信号
    function SuicideUntilSignal takes integer seconds, player p returns nothing
        local integer save
        local integer wave_prep = PrepTime()
    
        loop
            call AddSleepSeconds(seconds)
            if sleep_seconds-wave_prep > 0 then
                call SuicideSleep(sleep_seconds-wave_prep)
            endif
    
            set save = campaign_wood_peons
            set campaign_wood_peons = 0
            loop
                loop
                    call FormGroup(5, true)
                    exitwhen sleep_seconds <= 0
                    exitwhen CommandsWaiting() != 0
                endloop
                exitwhen SuicidePlayer(p,sleep_seconds >= -60)
                exitwhen CommandsWaiting() != 0
                call SuicideSleep(3)
            endloop
            set campaign_wood_peons = save
    
            loop
                exitwhen CaptainIsEmpty()
                exitwhen CommandsWaiting() != 0
                call SuicideSleep(5)
            endloop
            exitwhen CommandsWaiting() != 0
        endloop
    endfunction
    
    //--------------------------------------------------------------------------------------------------
   
    // 添加自杀单位类型到攻击组
    // @param easy 简单AI添加的数量
    // @param med 中等AI添加的数量
    // @param hard 疯狂AI添加的数量
    function SuicideOnce takes integer easy, integer med, integer hard, integer unitid returns nothing
        if difficulty == EASY then
            call SuicideUnit(easy,unitid)
        elseif difficulty == NORMAL then
            call SuicideUnit(med,unitid)
        else
            call SuicideUnit(hard,unitid)
        endif
    endfunction
    
    //--------------------------------------------------------------------------------------------------
   
    // 添加自杀单位类型到攻击组，每次添加1个
    function SuicideUnitA takes integer unitid returns nothing
        if unitid != 0 then
            call SuicideUnit(1,unitid)
        endif
        call Sleep(0.1)
    endfunction
    
    //--------------------------------------------------------------------------------------------------
   
    // 添加自杀单位类型到攻击组（指定被攻击的玩家），每次添加1个
    function SuicideUnitB takes integer unitid, integer playerid returns nothing
        if unitid != 0 then
            call SuicideUnitEx(1,unitid,playerid)
        endif
        call Sleep(0.1)
    endfunction
    
    //--------------------------------------------------------------------------------------------------
   
    // 循环添加自杀单位到单位组，该循环不会退出，只能作为单独线程使用
    // @param u1~uA 单位类型，可指定10种
    function SuicideUnits takes integer u1, integer u2, integer u3, integer u4, integer u5, integer u6, integer u7, integer u8, integer u9, integer uA returns nothing
        call Trace("MASS SUICIDE - this script is now technically done\n") //xxx
    
        call PrepFullSuicide()
        loop
            call SuicideUnitA(u1)
            call SuicideUnitA(u2)
            call SuicideUnitA(u3)
            call SuicideUnitA(u4)
            call SuicideUnitA(u5)
            call SuicideUnitA(u6)
            call SuicideUnitA(u7)
            call SuicideUnitA(u8)
            call SuicideUnitA(u9)
            call SuicideUnitA(uA)
        endloop
    endfunction
    
    //--------------------------------------------------------------------------------------------------
   
    // 循环添加自杀单位类型到单位组，该循环不会退出，只能作为单独线程使用
    // @param playerid 指定玩家
    // @param u1~uA 单位类型，可指定10种
    function SuicideUnitsEx takes integer playerid, integer u1, integer u2, integer u3, integer u4, integer u5, integer u6, integer u7, integer u8, integer u9, integer uA returns nothing
        call Trace("MASS SUICIDE - this script is now technically done\n") //xxx
    
        call PrepFullSuicide()
        loop
            call SuicideUnitB(u1,playerid)
            call SuicideUnitB(u2,playerid)
            call SuicideUnitB(u3,playerid)
            call SuicideUnitB(u4,playerid)
            call SuicideUnitB(u5,playerid)
            call SuicideUnitB(u6,playerid)
            call SuicideUnitB(u7,playerid)
            call SuicideUnitB(u8,playerid)
            call SuicideUnitB(u9,playerid)
            call SuicideUnitB(uA,playerid)
        endloop
    endfunction
    
    //--------------------------------------------------------------------------------------------------
   
    // 自杀式攻击（指定玩家）
    // @param easy 简单AI的等待时间
    // @param med 中等AI的等待时间
    // @param hard 疯狂AI的等待时间
    function SuicideOnPlayerEx takes integer easy, integer med, integer hard, player p returns nothing
        if difficulty == EASY then
            call SuicideOnPlayer(easy,p)
        elseif difficulty == NORMAL then
            call SuicideOnPlayer(med,p)
        else
            call SuicideOnPlayer(hard,p)
        endif
    endfunction
    
    //--------------------------------------------------------------------------------------------------
   
    // 自杀式攻击（指定玩家单位）
    // @param easy 简单AI的等待时间
    // @param med 中等AI的等待时间
    // @param hard 疯狂AI的等待时间
    function SuicideOnUnitsEx takes integer easy, integer med, integer hard, player p returns nothing
        if difficulty == EASY then
            call SuicideOnUnits(easy,p)
        elseif difficulty == NORMAL then
            call SuicideOnUnits(med,p)
        else
            call SuicideOnUnits(hard,p)
        endif
    endfunction
    
    //--------------------------------------------------------------------------------------------------
   
    // 自杀式攻击（指定玩家坐标）
    // @param easy 简单AI的等待时间
    // @param med 中等AI的等待时间
    // @param hard 疯狂AI的等待时间
    function SuicideOnPointEx takes integer easy, integer med, integer hard, player p, integer x, integer y returns nothing
        if difficulty == EASY then
            call SuicideOnPoint(easy,p,x,y)
        elseif difficulty == NORMAL then
            call SuicideOnPoint(med,p,x,y)
        else
            call SuicideOnPoint(hard,p,x,y)
        endif
    endfunction
    
    //============================================================================
    
    // 持续自杀式攻击（指定玩家）
    function ForeverSuicideOnPlayer takes integer seconds, player p returns nothing
        local integer length = harass_length
        loop
            exitwhen allow_signal_abort and CommandsWaiting() != 0
            call SuicideOnPlayer(seconds,p)
            set harass_length = length
        endloop
    endfunction
    
    //============================================================================
    
    // 战斗（循环发送发布攻击组进攻命令（指定目标）），直至攻击目标死亡或攻击组阵亡/撤退
    function CommonSleepUntilTargetDead takes unit target, boolean reform returns nothing
        loop
            exitwhen CaptainRetreating()
            exitwhen CaptainReadinessHP() <= 40
    
            exitwhen not UnitAlive(target)
            exitwhen UnitInvis(target) and not IsUnitDetected(target,ai_player)
    
            if not TownThreatened() then
                call AttackMoveKill(target)
            endif
    
            call SuicideSleep(3)
    
            if reform and sleep_seconds < -40 then
                if CaptainInCombat(true) then
                    set sleep_seconds = sleep_seconds + 5
                else
                    set sleep_seconds = 0
                    call FormGroup(1,false)
                endif
            endif
        endloop
    endfunction
    
    //============================================================================
    
    // 至死方休（指定目标），死为目标死亡或攻击组阵亡/撤退
    // 调用战斗程序 CommonSleepUntilTargetDead，且reform默认为假
    function SleepUntilTargetDead takes unit target returns nothing
        call CommonSleepUntilTargetDead(target,false)
    endfunction
    
    //============================================================================
    
    // 至死方休（指定目标），死为目标死亡或攻击组阵亡/撤退
    // 调用战斗程序 CommonSleepUntilTargetDead，且reform默认为真
    function ReformUntilTargetDead takes unit target returns nothing
        debug call Trace("ReformUntilTargetDead\n")
        call CommonSleepUntilTargetDead(target,true)
    endfunction
    
    //============================================================================
    
    // 攻击指定目标（移动攻击）
    function AttackMoveKillA takes unit target returns nothing
        if target == null then
            call SuicideSleep(3)
            return
        endif
    
        debug call Trace("AttackMoveKillA\n")
        call AttackMoveKill(target)
        call ReformUntilTargetDead(target)
        call SleepInCombat()
    endfunction
    
    //============================================================================
   // 攻击小型中立敌对玩家（打野）
    function MinorCreepAttack takes nothing returns nothing
        local unit target = GetMinorCreep()
        call SetAllianceTarget(target)
        call FormGroup(3, true)
        call AttackMoveKillA(target)
    endfunction
    
    //============================================================================
   // 攻击大型中立敌对玩家（打野）
    function MajorCreepAttack takes nothing returns nothing
        local unit target = GetMajorCreep()
        call SetAllianceTarget(target)
        call FormGroup(3,true)
        call AttackMoveKillA(target)
    endfunction
    
    //============================================================================
    
    // 攻击中立敌对玩家（打野）
    // 根据当前的min_creeps、max_creeps，allow_air_creeps获取野怪
    function CreepAttackEx takes nothing returns nothing
        local unit target = GetCreepCamp(min_creeps,max_creeps,allow_air_creeps)
        call SetAllianceTarget(target)
        call FormGroup(3,true)
        call AttackMoveKillA(target)
    endfunction
    
    //============================================================================
    
    // 攻击任意玩家
    function AnyPlayerAttack takes nothing returns nothing
        local unit hall
    
        set hall = GetEnemyExpansion()
        if hall == null then
            call StartGetEnemyBase()
            loop
                exitwhen not WaitGetEnemyBase()
                call SuicideSleep(1)
            endloop
            set hall = GetEnemyBase()
        endif
    
        call SetAllianceTarget(hall)
        call FormGroup(3,true)
        call AttackMoveKillA(hall)
    endfunction
    
    //============================================================================
    
    // 攻击扩张点（有中立敌对单位的分矿）
    function ExpansionAttack takes nothing returns nothing
        local unit creep = GetExpansionFoe()
        local integer x
    
        call FormGroup(3, true)
        if creep == null then
            set x = GetExpansionX()
            if x != -1 then
                call AttackMoveXYA(x,GetExpansionY())
            endif
        else
            call AttackMoveKillA(creep)
        endif
    endfunction
    
    //============================================================================
    //  AddSiege
    //============================================================================
    
    // 添加（默认攻击类型为）攻城单位到攻击组
    function AddSiege takes nothing returns nothing
        call SetAssaultGroup( 0, 9, SHADE       )
        call SetAssaultGroup( 0, 9, MEAT_WAGON  )
        call SetAssaultGroup( 0, 9, MORTAR      )
        call SetAssaultGroup( 0, 9, TANK        )
        call SetAssaultGroup( 0, 9, BALLISTA    )
        call SetAssaultGroup( 0, 9, CATAPULT    )
    endfunction
    
    //===========================================================================
    //  GetAllyCount
    //============================================================================
    
    // 获取盟友玩家数量
    function GetAllyCount takes player whichPlayer returns integer
        local integer    playerIndex = 0
        local integer    count = 0
        local player     indexPlayer
    
        loop
            set indexPlayer = Player(playerIndex)
    
            if whichPlayer != indexPlayer then
                if GetPlayerAlliance(whichPlayer,indexPlayer,ALLIANCE_PASSIVE) then
                    if GetPlayerAlliance(indexPlayer,whichPlayer,ALLIANCE_PASSIVE) then
                        if GetPlayerStructureCount(indexPlayer,true) > 0 then
                            set count = count + 1
                        endif
                    endif
                endif
            endif
             
            set playerIndex = playerIndex + 1
            exitwhen playerIndex == 12
        endloop
    
        return count
    endfunction
    
    //============================================================================
    //  SingleMeleeAttack
    //============================================================================
    
    // 对战进攻循环，包含打野、开矿、攻击玩家、购买飞艇等
    // @param needs_exp 是否开矿
    // @param has_siege 是否包含攻城单位
    // @param major_ok 是否允许攻击大型野怪营地（中立敌对玩家）
    // @param air_units 获取野怪营地时是否包含飞行单位
    function SingleMeleeAttack takes boolean needs_exp, boolean has_siege, boolean major_ok, boolean air_units returns nothing
        local boolean   can_siege
        local real      daytime 
        local unit      hall
        local unit      mega
        local unit      creep
        local unit      common
        local integer   minimum
        local boolean   allies
    
        call Trace("===SingleMeleeAttack===\n") //xxx
    
        if TownThreatened() then
            call Trace("sleep 2, town threatened\n") //xxx
            call Sleep(2)
            return
        endif
    
        // purchase zeppelins
        //
        if get_zeppelin and GetGold() > 300 and GetWood() > 100 then
            call Trace("purchase zep\n") //xxx
            call PurchaseZeppelin()
            set get_zeppelin = false
            set ready_for_zeppelin = false
            return
        endif
        set ready_for_zeppelin = true
    
        // coordinate with allies
        //
        set allies = GetAllyCount(ai_player) > 0
        if allies and MeleeDifficulty() != MELEE_NEWBIE then
            set common = GetAllianceTarget()
            if common != null then
                call Trace("join ally force\n") //xxx
                if GetMegaTarget() != null then
                    call AddSiege()
                endif
                call FormGroup(3,true)
                call AttackMoveKillA(common)
                call SetAllianceTarget(null)
                return
            endif
        endif
    
        // take expansions as needed
        //
        if needs_exp then
            call Trace("needs exp\n") //xxx
            set creep = GetExpansionFoe()
            if creep != null then
                call Trace("attack exp\n") //xxx
                call SetAllianceTarget(creep)
                call FormGroup(3,true)
                call AttackMoveKillA(creep)
                call Sleep(20)
                set take_exp = false
                return
            endif
        endif
    
        // all-out attack if the player is weak
        //
        if MeleeDifficulty() != MELEE_NEWBIE then
            set mega = GetMegaTarget()
            if mega != null then
                call Trace("MEGA TARGET!!!\n") //xxx
                call AddSiege()
                call FormGroup(3,true)
                call AttackMoveKillA(mega)
                return
            endif
        endif
    
        // deny player an expansion
        //
        set hall = GetEnemyExpansion()
        set daytime = GetFloatGameState(GAME_STATE_TIME_OF_DAY)
        set can_siege = has_siege and (air_units or (daytime>=4 and daytime<=12))
    
        if hall!=null and (can_siege or not IsTowered(hall)) then
    
            call Trace("test player town attack\n") //xxx
    
            if MeleeDifficulty() == MELEE_NEWBIE then
                set minimum = 3
            elseif allies and MeleeDifficulty() == MELEE_NORMAL then
                set minimum = 1
            else
                set minimum = 0 // HARD, INSANE, and NORMAL with no allies
            endif
    
            if exp_seen >= minimum then
                call Trace("do player town attack\n") //xxx
                set exp_seen = 0
                call AddSiege()
                call SetAllianceTarget(hall)
                call FormGroup(3,true)
                call AttackMoveKillA(hall)
                return
            endif
    
            set exp_seen = exp_seen + 1
        endif
    
        // attack player's main base when siege is available
        //
        if can_siege then
            call Trace("attack player's town\n") //xxx
            call AddSiege()
            call AnyPlayerAttack()
            return
        endif
    
        // extended, more specific method of determining creep levels
        //
        if min_creeps != -1 then
            call TraceI("custom creep attack %d\n",max_creeps) //xxx
            call CreepAttackEx()
            return
        endif
    
        // nothing better to do, so kill a creep camp
        //
        if major_ok then
            call Trace("major creep attack\n") //xxx
            call MajorCreepAttack()
            return
        endif
    
        call Trace("minor creep attack\n") //xxx
        call MinorCreepAttack()
    endfunction
    
    //============================================================================
    
    // 设置AI是否需要购买飞艇，该设置默认是自动的
    function GetZeppelin takes nothing returns nothing
        if ready_for_zeppelin then
            set get_zeppelin = true
        endif
    endfunction

    //============================================================================
    
    // 获取当前AI玩家的已使用人口数
    function FoodUsed takes nothing returns integer
        return GetPlayerState(ai_player,PLAYER_STATE_RESOURCE_FOOD_USED)
    endfunction
    
    //============================================================================
    
    // 获取当前AI玩家的可使用人口数（默认为人口建筑提供的总人口数）
    function FoodCap takes nothing returns integer
        return GetPlayerState(ai_player,PLAYER_STATE_RESOURCE_FOOD_CAP)
    endfunction
    
    //============================================================================
    
    // 获取当前AI玩家的未使用人口数（可使用人口数-已使用人口数）
    function FoodSpace takes nothing returns integer
        return FoodCap() - FoodUsed()
    endfunction
    
    //============================================================================
    
    // 获取当前AI玩家人口建筑提供的人口数
    // 公式：已建造完成的人口建筑数量（默认单位类型为racial_farm）*该建筑提供的人口数 + 已完成的城镇数量（单位类型用base指定）*该建筑提供的人口数
    function FoodAvail takes integer base returns integer
        return GetFoodMade(racial_farm) * TownCount(racial_farm) + GetFoodMade(base) * TownCount(base)
    endfunction
    
    //============================================================================
    
    // 训练攻击组单位
    function BuildAttackers takes nothing returns nothing
        local integer index = 0
        local integer unitid
        local integer desire
        local integer count
    
        loop
            exitwhen index == harass_length
    
            set unitid = harass_units[index]
            set desire = harass_qty[index] + IgnoredUnits(unitid)
            set count  = TownCount(unitid)
    
            if count != desire then
                if not StartUnit(desire,unitid,-1) then
                    return
                endif
            endif
    
            set index = index + 1
        endloop
    endfunction
    
    //============================================================================
    
    // 训练防御组单位
    function BuildDefenders takes nothing returns nothing
        local integer index = 0
        local integer unitid
        local integer qty
        loop
            exitwhen index == defense_length
    
            set unitid = defense_units[index]
            set qty = defense_qty[index]
    
            call Conversions(qty,unitid)
            call AddDefenders(qty,unitid)
    
            set index = index + 1
        endloop
    endfunction
    
    //============================================================================
    
    // 战役循环，自动运行战役默认的采集/建造/训练/研究命令
    function CampaignBasicsA takes nothing returns nothing
        local integer food_each = GetFoodMade(racial_farm)
        local integer on_wood
    
        call ClearHarvestAI()
    
        if CaptainInCombat(false) then
            set on_wood = 0
        else
            set on_wood = campaign_wood_peons
        endif
    
        call HarvestGold(0,campaign_gold_peons)
        call HarvestWood(0,on_wood)
    
        if harvest_town1 then
            call HarvestGold(1,campaign_gold_peons)
            call HarvestWood(1,on_wood)
        endif
    
        if harvest_town2 then
            call HarvestGold(2,campaign_gold_peons)
            call HarvestWood(2,on_wood)
        endif
    
        if harvest_town3 then
            call HarvestGold(3,campaign_gold_peons)
            call HarvestWood(3,on_wood)
        endif
    
        if do_campaign_farms and FoodUsed()+food_each-1 > food_each*(TownCount(racial_farm)+1) then
            call StartUnit(TownCount(racial_farm)+1,racial_farm,-1)
        endif
    
        if build_campaign_attackers then
            call BuildAttackers()
        endif
    
        if not CaptainInCombat(false) then
            call BuildDefenders()
        endif
    
        call FillGuardPosts()
        call ReturnGuardPosts()
    endfunction
    
    //============================================================================
    
    // 战役基础线程，内置战役循环
    function CampaignBasics takes nothing returns nothing
        call Sleep(1)
        call CampaignBasicsA()
        call StaggerSleep(1,5)
        loop
            call CampaignBasicsA()
            call Sleep(campaign_basics_speed)
        endloop
    endfunction
    
    //============================================================================
    
    // 运行战役AI，运行后开始运行战役基础线程
    // @param farms 指定人口建筑的单位类型（即指定racial_farm）
    // @param heroes 指定英雄升级函数
    function CampaignAI takes integer farms, code heroes returns nothing
        if GetGameDifficulty() == MAP_DIFFICULTY_EASY then
            set difficulty = EASY
    
            call SetTargetHeroes(false)
            call SetUnitsFlee(false)
    
        elseif GetGameDifficulty() == MAP_DIFFICULTY_NORMAL then
            set difficulty = NORMAL
    
            call SetTargetHeroes(false)
            call SetUnitsFlee(false)
    
        elseif GetGameDifficulty() == MAP_DIFFICULTY_HARD then
            set difficulty = HARD
    
            call SetPeonsRepair(true)
        else
            set difficulty = INSANE
        endif
    
        call InitAI()
        call InitBuildArray()
        call InitAssaultGroup()
        call CreateCaptains()
    
        call SetNewHeroes(false)
        if heroes != null then
            call SetHeroLevels(heroes)
        endif
    
        call SetHeroesFlee(false)
        call SetGroupsFlee(false)
        call SetSlowChopping(true)
        call GroupTimedLife(false)
        call SetCampaignAI()
        call Sleep(0.1)
    
        set racial_farm = farms
        call StartThread(function CampaignBasics)
        call StartBuildLoop()
    endfunction
    
    //============================================================================
    
    // 取消一切，会取消正在建造/训练/研究的单位/科技
    function UnsummonAll takes nothing returns nothing
        local unit bldg
        loop
            set bldg = GetBuilding(ai_player)
            exitwhen bldg==null
            call Unsummon(bldg)
            call Sleep(2)
        endloop
    endfunction
    
    //============================================================================
    //  SkillArrays
    //============================================================================
    
    // 升级后自动学习技能线程，让英雄升级后根据 SetSkillArray 的顺序自动学习技能
    // 该代码在1.30中因官方BUG无法运行，需要手动使用触发或魔改该代码修正
    function SkillArrays takes nothing returns integer
        local integer level = GetHeroLevelAI()
    
        if level > max_hero_level then
            set max_hero_level = level
        endif
    
        if GetHeroId() == hero_id then
            return skills1[level]
        elseif GetHeroId() == hero_id2 then
            return skills2[level]
        else
            return skills3[level]
        endif
    endfunction
    
    //--------------------------------------------------------------------------------------------------
    //  SetSkillArray
    //--------------------------------------------------------------------------------------------------
   
    // 设置3个英雄的技能学习顺序，默认只能设置10级
    // @param index 仅可输入1和2，其他值都会默认视为3，分别代表首、二、三发英雄
    // @param id 分别代表首、二、三发英雄对应的单位类型
    function SetSkillArray takes integer index, integer id returns nothing
        local integer i = 1
    
        if index == 1 then
            if hero_id != id then
                return
            endif
            loop
                set skills1[i] = skill[i]
                exitwhen i == 10
                set i = i + 1
            endloop
        elseif index == 2 then
            if hero_id2 != id then
                return
            endif
            loop
                set skills2[i] = skill[i]
                exitwhen i == 10
                set i = i + 1
            endloop
        else
            if hero_id3 != id then
                return
            endif
            loop
                set skills3[i] = skill[i]
                exitwhen i == 10
                set i = i + 1
            endloop
        endif
    endfunction
    
    //============================================================================
    //  AwaitMeleeHeroes
    //============================================================================
    
    // 等待二发英雄
    // 当首发英雄完成训练/复活，且 【take_exp为真 或 二发英雄存在且完成训练/复活时】 结束等待，否则循环等待
    function AwaitMeleeHeroes takes nothing returns nothing
        if GetUnitCountDone(hero_id2) > 0 then
            set two_heroes = true
        endif
        loop
            exitwhen GetUnitCountDone(hero_id)>0 and (take_exp or (not two_heroes or GetUnitCountDone(hero_id2)>0))
            call Sleep(1)
        endloop
    endfunction
    
    //============================================================================
    //  PickMeleeHero 
    //============================================================================
    
    // 设置对战英雄（含混乱之治和冰封王座），设置4个种族的默认英雄（不含中立）及本局随机顺序（首发，二发，三发）
    // @param raceid 种族，4族之外的其他种族会默认为空
    // heroes[4]默认为冰封王座新加的英雄，不会出现在混乱之治中
    function PickMeleeHero takes race raceid returns integer
        local integer first
        local integer second
        local integer third
        local integer last
        local integer array heroes
    
        //------------------------------------------------------------------------
        if raceid == RACE_HUMAN then
        //------------------------------------------------------------------------
            set heroes[1] = ARCHMAGE
            set heroes[2] = MTN_KING
            set heroes[3] = PALADIN
            set heroes[4] = BLOOD_MAGE
    
        //------------------------------------------------------------------------
        elseif raceid == RACE_ORC then
        //------------------------------------------------------------------------
            set heroes[1] = BLADE_MASTER
            set heroes[2] = FAR_SEER
            set heroes[3] = TAUREN_CHIEF
            set heroes[4] = SHADOW_HUNTER
    
        //------------------------------------------------------------------------
        elseif raceid == RACE_NIGHTELF then
        //------------------------------------------------------------------------
            set heroes[1] = DEMON_HUNTER
            set heroes[2] = KEEPER
            set heroes[3] = MOON_BABE
            set heroes[4] = WARDEN
    
        //------------------------------------------------------------------------
        elseif raceid == RACE_UNDEAD then
        //------------------------------------------------------------------------
            set heroes[1] = DEATH_KNIGHT
            set heroes[2] = DREAD_LORD
            set heroes[3] = LICH
            set heroes[4] = CRYPT_LORD
        else
            set hero_id = 0
        endif
    
        if VersionCompatible(VERSION_FROZEN_THRONE) then
            set last = 4
        else
            set last = 3
        endif
    
        set first  = GetRandomInt(1,last)
        set second = GetRandomInt(1,last-1)
        set third  = GetRandomInt(1,last-2)
    
        set hero_id        = heroes[first]
        set heroes[first]  = heroes[last]
        set hero_id2       = heroes[second]
        set heroes[second] = heroes[last-1]
        set hero_id3       = heroes[third]
    
        return hero_id
    endfunction
